<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pysnptools Documentation &mdash; pysnptools 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pysnptools 0.0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pysnptools 0.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="pysnptools-documentation">
<h1><a class="reference internal" href="#module-pysnptools" title="pysnptools"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools</span></tt></a> Documentation<a class="headerlink" href="#pysnptools-documentation" title="Permalink to this headline">¶</a></h1>
<p>PySnpTools: A library for reading and manipulating genetic data.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">synopsis:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<ul class="simple">
<li><a class="reference internal" href="#module-pysnptools.snpreader" title="pysnptools.snpreader"><tt class="xref py py-mod docutils literal"><span class="pre">snpreader</span></tt></a>: Efficiently read genetic PLINK formats including *.bed/bim/fam and phenotype files. Also, efficiently read <em>parts</em> of files and standardize data.</li>
<li><a class="reference internal" href="#module-pysnptools.kernelreader" title="pysnptools.kernelreader"><tt class="xref py py-mod docutils literal"><span class="pre">kernelreader</span></tt></a>: Efficiently read and manipulate kernel data.</li>
<li><a class="reference internal" href="#module-pysnptools.util" title="pysnptools.util"><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt></a>: In one line, intersect and re-order IIDs from <a class="reference internal" href="#module-pysnptools.snpreader" title="pysnptools.snpreader"><tt class="xref py py-mod docutils literal"><span class="pre">snpreader</span></tt></a>, <a class="reference internal" href="#module-pysnptools.kernelreader" title="pysnptools.kernelreader"><tt class="xref py py-mod docutils literal"><span class="pre">kernelreader</span></tt></a> and other sources. Also, efficiently extract a submatrix from an ndarray.</li>
<li><a class="reference internal" href="#pysnptools.util.IntRangeSet" title="pysnptools.util.IntRangeSet"><tt class="xref py py-class docutils literal"><span class="pre">util.IntRangeSet</span></tt></a>: Efficiently manipulate ranges of integers &#8211; for example, genetic position &#8211; with set operators including
union, intersection, and set difference.</li>
<li><a class="reference internal" href="#module-pysnptools.pstreader" title="pysnptools.pstreader"><tt class="xref py py-mod docutils literal"><span class="pre">pstreader</span></tt></a>: Generalizes <a class="reference internal" href="#module-pysnptools.snpreader" title="pysnptools.snpreader"><tt class="xref py py-mod docutils literal"><span class="pre">snpreader</span></tt></a> and <a class="reference internal" href="#module-pysnptools.kernelreader" title="pysnptools.kernelreader"><tt class="xref py py-mod docutils literal"><span class="pre">kernelreader</span></tt></a> (provides the efficiency of numpy arrays with some of the flexibility of pandas)</li>
</ul>
<span class="target" id="module-pysnptools"></span><div class="section" id="module-pysnptools.snpreader">
<span id="snpreader-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">snpreader</span></tt> Module<a class="headerlink" href="#module-pysnptools.snpreader" title="Permalink to this headline">¶</a></h2>
<p>Tools for reading SNP files</p>
<div class="section" id="snpreader-snpreader">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.SnpReader</span></tt><a class="headerlink" href="#snpreader-snpreader" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.SnpReader">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">SnpReader</tt><a class="headerlink" href="#pysnptools.snpreader.SnpReader" title="Permalink to this definition">¶</a></dt>
<dd><p>A SnpReader is one of three things:</p>
<ul>
<li><p class="first">A class such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a> for you to specify data in a file. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span> <span class="c"># prints specification for reading from file</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_count</span> <span class="c"># prints the number of SNPS (but doesn&#39;t read any SNP values)</span>
<span class="go">1015</span>
</pre></div>
</div>
</li>
<li><p class="first">A <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> class that holds SNP data in memory, typically after reading it from disk:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#reads the SNP values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The val property is an ndarray of SNP values</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># prints the specification of the in-memory SNP information</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">iid_count</span> <span class="c">#prints the number of iids (number of individuals) in this in-memory data</span>
<span class="go">300</span>
</pre></div>
</div>
</li>
<li><p class="first">A subset of any SnpReader, specified with &#8220;[ <em>iid_index</em> , <em>sid_index</em> ]&#8221;, to read only some SNP values. It can
also be used to re-order the values.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># specification for a subset of the data on disk. No SNP values are read yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">sid_count</span> <span class="c"># prints the number of sids in this subset (but still doesn&#39;t read any SNP values)</span>
<span class="go">508</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c">#prints a specification of &#39;subset_on_disk&#39;</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># efficiently reads the specified subset of values from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span> <span class="c"># prints the specification of the in-memory SNP information</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span> <span class="c"># The dimensions of the ndarray of SNP values</span>
<span class="go">(2L, 508L)</span>
</pre></div>
</div>
</li>
</ul>
<p>Methods &amp; Properties:</p>
<blockquote>
<div><p>Every SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a> and <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, has these properties: <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid" title="pysnptools.snpreader.SnpReader.iid"><tt class="xref py py-attr docutils literal"><span class="pre">iid</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid" title="pysnptools.snpreader.SnpReader.sid"><tt class="xref py py-attr docutils literal"><span class="pre">sid</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid_count" title="pysnptools.snpreader.SnpReader.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>,
<a class="reference internal" href="#pysnptools.snpreader.SnpReader.pos" title="pysnptools.snpreader.SnpReader.pos"><tt class="xref py py-attr docutils literal"><span class="pre">pos</span></tt></a> and these methods: <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid_to_index" title="pysnptools.snpreader.SnpReader.iid_to_index"><tt class="xref py py-meth docutils literal"><span class="pre">iid_to_index()</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid_to_index" title="pysnptools.snpreader.SnpReader.sid_to_index"><tt class="xref py py-meth docutils literal"><span class="pre">sid_to_index()</span></tt></a>, <tt class="xref py py-meth docutils literal"><span class="pre">kernelreader()</span></tt>. See below for details.</p>
<p><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> is a SnpReader so it supports the above properties and methods. In addition, it supports property <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> and method <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>.
See below for details.</p>
</div></blockquote>
<p>iids and sids:</p>
<blockquote>
<div><p>Individual are identified with an iid, which is a ndarray of two strings: a family ID and a case ID. SNP locations 
are identified with sid string. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</div></blockquote>
<p>When Data is Read:</p>
<blockquote>
<div><p>SNP data can be enormous so we generally avoid reading it to the degree practical. Specifically,</p>
<ul>
<li><p class="first">Constructing and printing a SnpReader causes no file reading. For example, these commands read no data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span> <span class="c"># Print the Bed SnpReader specification. No data is read.</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c"># print the subset SnpReader. No data is read.</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2]</span>
</pre></div>
</div>
</li>
<li><p class="first">Properties and methods related to the iids and sids (to the degree practical) read just some iid and sid data from the disk,
not SNP value data. Moreover, the iid and sid data is read from file only once. Consider these commands:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># without reading any SNP values data from disk, read the sid and iid data from disk, cache it, and then print the first ten sids.</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#use the cached sid information to find the indexes of &#39;1_10&#39; and &#39;1_13&#39;. (No data is read from disk.)</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</li>
<li><p class="first">The only methods that read SNP values from file are <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> and <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read_kernel" title="pysnptools.snpreader.SnpReader.read_kernel"><tt class="xref py py-meth docutils literal"><span class="pre">read_kernel()</span></tt></a> (to the degree practical). For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#read all the SNP values from disk, creating a new SnpData instance that keeps these values in memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the SNP value for the iid with index 0 and the sid with index 2. (No data is read from disk.)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</li>
<li><p class="first">If you request the values for only a subset of the iids or sids, (to the degree practical) only that subset will be read from disk.
for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># from disk, read the SNP values for the iids with index 3 and 4 AND sids with even numbered indexes.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the SNP value with subset iid index 0 and sid index 2 (corresponding to iid index 3 and sid index 4 in the full data). No data is read from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>When Data is Re-Read and Copied:</p>
<blockquote>
<div><p>Every time you call a SnpReader&#8217;s <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> method, the SnpReader re-reads the SNP value data and returns a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>
(with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values). Likewise, when you call the <a class="reference internal" href="#pysnptools.snpreader.SnpReader.kernel" title="pysnptools.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt></a> method, the SnpReader re-reads
the data and returns a new kernel ndarray.</p>
<p>Here is an example of what not to do, because it causes all the SNP value data to be read twice.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># The following is not recommended because it inefficiently reads all the SNP values twice.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># read all values into a new SnpData, print a SNP value</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># read all values (again) into a second new SnpData, print a SNP value</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Here are two efficient alternatives. First, if all SNP values can all fit in memory, read them once into a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> and then
access that <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> multiple times.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all values into a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print a SNP value from snpdata1&#39;s in-memory ndarray</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print another SNP value from snpdata1&#39;s in-memory ndarray.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Second, if the SNP value data is too large to fit in memory, use subsetting to read only the SNP values of interest from disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define the subset of data and read only that subset from disk.</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define a second subset of data and read only that subset from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Because the in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> class is a kind of SnpReader, you may read from it, too.
Doing so create a new <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> instance containing a copy of the SNP values in a new ndarray.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values from disk into a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the in-memory SNP values use the same memory as themselves? Yes</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># copy all the SNP values into a new ndarray in a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the two ndarrays of in-memory SNP values use the same memory?</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Avoiding Unwanted ndarray Allocations</p>
<blockquote>
<div><p>You may want a subset of SNPs values from an in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> and you may know that this subset and the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>
can safely share the memory of the ndarray of SNP values. For this case, the <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> has optional parameters called view_ok and order. If you override 
the defaults of &#8220;view_ok=False,order=&#8217;F&#8217;&#8221; with &#8220;view_ok=True,order=&#8217;A&#8217;, the <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> will, if practical, return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original ndarray.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all data from disk into a SnpData with a new ndarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column01</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create SnpData with the data from just the first two SNPs. Sharing memory is OK. The memory may be laid out in any order (that is sid-major and iid-major are both OK).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#print np.may_share_memory(snpdata1.val, column01.val) # Do the two ndarray&#39;s share memory? They could (but currently they won&#39;t)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column201</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create SnpData with the data from three SNPs, permuted. Sharing memory is OK.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">column201</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># Do the two ndarray&#39;s share memory? No, ndarray decided that this indexing was too complex for sharing.</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Creating Subsetting SnpReaders with Indexing</p>
<blockquote>
<div><p>You often don&#8217;t want to read the SNP values for all iids and sids. You can use indexing to create a subsetting SnpReader that
will read only the SNP values of interest.</p>
<p>SnpReaders support the indexing formats supported by ndarray plus two generalizations. Here are examples of indexing with an array
of indexes, with slicing, and with an array of Booleans.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:]</span> <span class="c">#index with an array of indexes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">2 1015</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read just the two rows of interest from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c">#index with a slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_2</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_2</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">300 507</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boolindexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;23_&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">]</span> <span class="c"># create a Boolean index of sids that start &#39;23_&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_3</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,</span><span class="n">boolindexes</span><span class="p">]</span> <span class="c">#index with array of Booleans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_3</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_3</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">300 24</span>
</pre></div>
</div>
<p>The first generalization over with ndarray offers is full indexing on both the iid dimension and the sid dimension, in other words,
full multidimensional indexing. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_4</span><span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c"># index on two dimensions at once</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_4</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_4</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">2 507</span>
</pre></div>
</div>
<p>The second generalization is indexing on a single integer index.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_5</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span> <span class="c">#index with single integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_5</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_5</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">1 1015</span>
</pre></div>
</div>
<p>Indexing is also useful when you have SNP values in memory via a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> index and want to copy a subset of those values.
While you could instead index directly on the <cite>.SnpData.val</cite> ndarray, by indexing on the <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> instance you
also get iid and cid information.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c"># create a copy or view with every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 sids in the subset</span>
<span class="go">[&#39;1_12&#39; &#39;1_10&#39; &#39;1_28&#39; &#39;1_36&#39; &#39;1_4&#39; &#39;1_11&#39; &#39;1_32&#39; &#39;1_9&#39; &#39;1_17&#39; &#39;1_18&#39;]</span>
</pre></div>
</div>
<p>You can apply indexing on top of indexing to specify subsets of subsets of data to read. In this example, 
only the SNP values for every 16th sid is actually read from the disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># These are just SnpReaders, nothing is read from disk yet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_snpreader</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quarter_snpreader</span> <span class="o">=</span> <span class="n">half_snpreader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sixteenth_snpreader</span> <span class="o">=</span> <span class="n">quarter_snpreader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">][:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half of half of half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sixteenth_snpreader</span> <span class="c">#Print the specification of this reader</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[:,::2][:,::2][:,::2][:,::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now we read from disk. Only values for one sid in every 16 will be read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_sixteenth</span> <span class="o">=</span> <span class="n">sixteenth_snpreader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_sixteenth</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">2.0</span>
</pre></div>
</div>
</div></blockquote>
<p>The <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> Method</p>
<blockquote>
<div>By default the <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> returns a ndarray of scipy.float64 laid out in memory in F-contiguous order (iid-index varies the fastest). You may, instead,
ask for scipy.float32 or for C-contiguous order or any order. See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> for details.</div></blockquote>
<dl class="docutils">
<dt>The <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> Method</dt>
<dd><p class="first">The <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> method, available only on <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, does in-place standardization of the in-memory
SNP data. By default, it applies &#8216;Unit&#8217; standardization, that is: the values for each SNP will have mean zero and standard deviation 1.0.
NaN values are then filled with zero, the mean (consequently, if there are NaN values, the final standard deviation will not be zero.
Note that, for efficiently, this method works in-place, actually changing values in the ndarray. Although it works in place, for convenience
it also returns itself. See <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> for options and details.</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># Prints the specification for this SnpData</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># standardize changes the values in snpdata1.val and changes the specification.</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;),Unit())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># Read and standardize in one expression with only one ndarray allocated.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
</pre></div>
</div>
</dd>
</dl>
<p>The <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read_kernel" title="pysnptools.snpreader.SnpReader.read_kernel"><tt class="xref py py-meth docutils literal"><span class="pre">read_kernel()</span></tt></a> Method !!!cmk0</p>
<blockquote>
<div>The <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read_kernel" title="pysnptools.snpreader.SnpReader.read_kernel"><tt class="xref py py-meth docutils literal"><span class="pre">read_kernel()</span></tt></a> method, available on any SnpReader, returns a <tt class="xref py py-class docutils literal"><span class="pre">KernelData</span></tt>. The <tt class="xref py py-meth docutils literal"><span class="pre">val()</span></tt> property of the <tt class="xref py py-class docutils literal"><span class="pre">KernelData</span></tt> is
an ndarray of the (optionally standardized) SNP values transposed and then multiplied with themselves. When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>,
the method can save memory by reading (and standardizing) the data in blocks. See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read_kernel" title="pysnptools.snpreader.SnpReader.read_kernel"><tt class="xref py py-meth docutils literal"><span class="pre">read_kernel()</span></tt></a> for details.</div></blockquote>
<dl class="attribute">
<dt id="pysnptools.snpreader.SnpReader.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpReader.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpReader.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpReader.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpReader.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpReader.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpReader.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpReader.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpReader.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.SnpReader.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid_count" title="pysnptools.snpreader.SnpReader.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpReader.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpReader.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpReader.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpReader.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.SnpReader.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpReader.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpReader.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid_count" title="pysnptools.snpreader.SnpReader.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpReader.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpReader.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpReader.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpReader.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="snpreader-bed">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.Bed</span></tt><a class="headerlink" href="#snpreader-bed" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.Bed">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">Bed</tt><big>(</big><em>basefilename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that does random-access reads of a Bed/Bim/Fam files from disk.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> for details and examples.</p>
<dl class="docutils">
<dt>Constructor:</dt>
<dd><dl class="first last docutils">
<dt>basefilename <span class="classifier-delimiter">:</span> <span class="classifier">string of the basename of [basename].bed, [basename].bim,</span></dt>
<dd>and [basename].fam</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.col" title="Permalink to this definition">¶</a></dt>
<dd><p>list of sids</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.col_property" title="Permalink to this definition">¶</a></dt>
<dd><p>list of position information</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Bed.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Bed.iid_count" title="pysnptools.snpreader.Bed.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Bed.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Bed.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.Bed.iid_count" title="pysnptools.snpreader.Bed.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.Bed.iid_count" title="pysnptools.snpreader.Bed.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Bed.sid_count" title="pysnptools.snpreader.Bed.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Bed.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.Bed.read" title="pysnptools.snpreader.Bed.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Bed.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.row" title="Permalink to this definition">¶</a></dt>
<dd><p>list of iids</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Bed.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Bed.sid_count" title="pysnptools.snpreader.Bed.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Bed.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Bed.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Bed.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.Bed.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>basefilename</em>, <em>snpdata</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Bed.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="snpreader-pheno">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.Pheno</span></tt><a class="headerlink" href="#snpreader-pheno" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.Pheno">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">Pheno</tt><big>(</big><em>input</em>, <em>iid_if_none=None</em>, <em>missing=None</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that reads into memory from pheno files or from in-memory pheno dictionaries</p>
<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Pheno.iid_count" title="pysnptools.snpreader.Pheno.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.Pheno.iid_count" title="pysnptools.snpreader.Pheno.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.Pheno.iid_count" title="pysnptools.snpreader.Pheno.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Pheno.sid_count" title="pysnptools.snpreader.Pheno.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.Pheno.read" title="pysnptools.snpreader.Pheno.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Pheno.sid_count" title="pysnptools.snpreader.Pheno.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Pheno.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Pheno.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Pheno.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.Pheno.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>snpdata</em>, <em>missing='NaN'</em>, <em>sep='t'</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Pheno.write" title="Permalink to this definition">¶</a></dt>
<dd><p>!!!cmk</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="snpreader-snpdata">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.SnpData</span></tt><a class="headerlink" href="#snpreader-snpdata" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.SnpData">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">SnpData</tt><big>(</big><em>iid</em>, <em>sid</em>, <em>val</em>, <em>pos=None</em>, <em>parent_string=''</em>, <em>copyinputs_function=None</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class hold SNP values in-memory along with related iid and sid information.
It is created by calling the <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">SnpReader.read()</span></tt></a> method on another <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a>, for example, <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> for details and examples.</p>
<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.col" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid" title="pysnptools.snpreader.SnpReader.sid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.sid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.col_property" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.pos" title="pysnptools.snpreader.SnpReader.pos"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.pos</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpData.iid_count" title="pysnptools.snpreader.SnpData.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.SnpData.iid_count" title="pysnptools.snpreader.SnpData.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.SnpData.iid_count" title="pysnptools.snpreader.SnpData.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpData.sid_count" title="pysnptools.snpreader.SnpData.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.SnpData.read" title="pysnptools.snpreader.SnpData.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.row" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid" title="pysnptools.snpreader.SnpReader.iid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.iid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.row_property" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.pos" title="pysnptools.snpreader.SnpReader.pos"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.pos</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpData.sid_count" title="pysnptools.snpreader.SnpData.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpData.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpData.standardize">
<tt class="descname">standardize</tt><big>(</big><em>standardizer=Unit()</em>, <em>block_size=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpData.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Does in-place standardization of the in-memory
SNP data. By default, it applies &#8216;Unit&#8217; standardization, that is: the values for each SNP will have mean zero and standard deviation 1.0.
NaN values are then filled with zero, the mean (consequently, if there are NaN values, the final standard deviation will not be zero.
Note that, for efficiently, this method works in-place, actually changing values in the ndarray. Although it works in place, for convenience
it also returns itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; optional &#8211; Specify standardization to be applied before the matrix multiply. 
Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (default, makes values for each SNP have mean zero and
standard deviation 1.0)and <a class="reference internal" href="#pysnptools.standardizer.Beta" title="pysnptools.standardizer.Beta"><tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt></a>.</li>
<li><strong>block_size</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of None. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (standardizes in place, but for convenience, returns &#8216;self&#8217;)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># Prints the specification for this SnpData</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># standardize changes the values in snpdata1.val and changes the specification.</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;),Unit())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># Read and standardize in one expression with only one ndarray allocated.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpData.val">
<tt class="descname">val</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.snpreader.SnpData.val" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="snpreader-ped">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.Ped</span></tt><a class="headerlink" href="#snpreader-ped" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.Ped">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">Ped</tt><big>(</big><em>filename</em>, <em>missing='0'</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that does a Ped file. For examples of its use see its &#8216;read&#8217; method. #!!LATER update comments
#!!!cmk mention that 012 may become 210</p>
<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Ped.iid_count" title="pysnptools.snpreader.Ped.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.Ped.iid_count" title="pysnptools.snpreader.Ped.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.Ped.iid_count" title="pysnptools.snpreader.Ped.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Ped.sid_count" title="pysnptools.snpreader.Ped.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.Ped.read" title="pysnptools.snpreader.Ped.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Ped.sid_count" title="pysnptools.snpreader.Ped.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Ped.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Ped.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Ped.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.Ped.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>snpdata</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Ped.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="snpreader-dat">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.Dat</span></tt><a class="headerlink" href="#snpreader-dat" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.Dat">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">Dat</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that reads into memory from DAT/FAM/MAP files.</p>
<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Dat.iid_count" title="pysnptools.snpreader.Dat.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.Dat.iid_count" title="pysnptools.snpreader.Dat.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.Dat.iid_count" title="pysnptools.snpreader.Dat.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Dat.sid_count" title="pysnptools.snpreader.Dat.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.Dat.read" title="pysnptools.snpreader.Dat.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.Dat.sid_count" title="pysnptools.snpreader.Dat.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.Dat.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.Dat.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.Dat.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.Dat.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>snpdata</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.Dat.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="snpreader-snphdf5">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.SnpHdf5</span></tt><a class="headerlink" href="#snpreader-snphdf5" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.SnpHdf5">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">SnpHdf5</tt><big>(</big><em>filename</em>, <em>block_size=5000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.create_block">
<tt class="descname">create_block</tt><big>(</big><em>block_size</em>, <em>order</em>, <em>dtype</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.create_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.h5">
<tt class="descname">h5</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.h5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpHdf5.iid_count" title="pysnptools.snpreader.SnpHdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.SnpHdf5.iid_count" title="pysnptools.snpreader.SnpHdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.SnpHdf5.iid_count" title="pysnptools.snpreader.SnpHdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpHdf5.sid_count" title="pysnptools.snpreader.SnpHdf5.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.SnpHdf5.read" title="pysnptools.snpreader.SnpHdf5.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.read_direct">
<tt class="descname">read_direct</tt><big>(</big><em>val</em>, <em>selection=(slice(None</em>, <em>None</em>, <em>None)</em>, <em>slice(None</em>, <em>None</em>, <em>None))</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.read_direct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpHdf5.sid_count" title="pysnptools.snpreader.SnpHdf5.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpHdf5.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpHdf5.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.SnpHdf5.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>pstdata</em>, <em>dtype='f8'</em>, <em>col_major=True</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpHdf5.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="snpreader-snpnpz">
<h3><tt class="xref py py-class docutils literal"><span class="pre">snpreader.SnpNpz</span></tt><a class="headerlink" href="#snpreader-snpnpz" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.SnpNpz">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.</tt><tt class="descname">SnpNpz</tt><big>(</big><em>pstnpz_filename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpNpz.iid_count" title="pysnptools.snpreader.SnpNpz.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any class from <a class="reference internal" href="#module-pysnptools.standardizer" title="pysnptools.standardizer"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools.standardizer</span></tt></a> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.Identity" title="pysnptools.standardizer.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.SnpNpz.iid_count" title="pysnptools.snpreader.SnpNpz.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.SnpNpz.iid_count" title="pysnptools.snpreader.SnpNpz.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpNpz.sid_count" title="pysnptools.snpreader.SnpNpz.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.SnpNpz.read" title="pysnptools.snpreader.SnpNpz.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.read_kernel">
<tt class="descname">read_kernel</tt><big>(</big><em>standardizer</em>, <em>block_size=None</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.read_kernel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.SnpNpz.sid_count" title="pysnptools.snpreader.SnpNpz.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.SnpNpz.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.SnpNpz.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.SnpNpz.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>pstdata</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.SnpNpz.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="kernelreader-module">
<h2><tt class="xref py py-mod docutils literal"><span class="pre">kernelreader</span></tt> Module<a class="headerlink" href="#kernelreader-module" title="Permalink to this headline">¶</a></h2>
<span class="target" id="module-pysnptools.kernelreader"></span><p>Tools for reading SNP files #!!!cmkfix comment</p>
<div class="section" id="kernelreader-kernelreader">
<h3><tt class="xref py py-class docutils literal"><span class="pre">kernelreader.KernelReader</span></tt><a class="headerlink" href="#kernelreader-kernelreader" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.kernelreader.KernelReader">
<em class="property">class </em><tt class="descclassname">pysnptools.kernelreader.</tt><tt class="descname">KernelReader</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader" title="Permalink to this definition">¶</a></dt>
<dd><p>The (abstract) base class for you to specify SNP data and later read it.</p>
<p>A SnpReader is one of three things:</p>
<ul>
<li><p class="first">A class such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a> for you to specify data in file. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span> <span class="c"># prints specification for reading from file</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_count</span> <span class="c"># prints the number of SNPS (but doesn&#39;t read any SNP values)</span>
<span class="go">1015</span>
</pre></div>
</div>
</li>
<li><p class="first">A <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> class that holds SNP data in memory, typically after a read:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#reads the SNP values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The val property is an ndarray of SNP values</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># prints the specification of the in-memory SNP information</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">iid_count</span> <span class="c">#prints the number of iids (number of individuals) in this in-memory data</span>
<span class="go">300</span>
</pre></div>
</div>
</li>
<li><p class="first">A subset of any SnpReader, specified with &#8220;[ <em>iid_index</em> , <em>sid_index</em> ]&#8221;, to read only some SNP values.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># specification for a subset of the data on disk. No SNP values are read yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">sid_count</span> <span class="c"># prints the number of sids in this subset (but still doesn&#39;t read any SNP values)</span>
<span class="go">508</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c">#prints a specification of &#39;subset_on_disk&#39;</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># efficiently reads the specified subset of values from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span> <span class="c"># prints the specification of the in-memory SNP information</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c"># The dimensions of the ndarray of SNP values</span>
<span class="go">(2, 508)</span>
</pre></div>
</div>
</li>
</ul>
<p>Methods &amp; Properties:</p>
<blockquote>
<div><p>Every SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a> and <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, has these properties: <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.iid" title="pysnptools.kernelreader.KernelReader.iid"><tt class="xref py py-attr docutils literal"><span class="pre">iid</span></tt></a>, <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.iid_count" title="pysnptools.kernelreader.KernelReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>, <tt class="xref py py-attr docutils literal"><span class="pre">sid</span></tt>, <tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt>,
<tt class="xref py py-attr docutils literal"><span class="pre">pos</span></tt> and these methods: <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a>, <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.iid_to_index" title="pysnptools.kernelreader.KernelReader.iid_to_index"><tt class="xref py py-meth docutils literal"><span class="pre">iid_to_index()</span></tt></a>, <tt class="xref py py-meth docutils literal"><span class="pre">sid_to_index()</span></tt>, <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt>. See below for details.</p>
<p><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> is a SnpReader so it supports the above properties and method. In addition, it supports property <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> and method <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>.
See below for details.</p>
</div></blockquote>
<p>iids and sids:</p>
<blockquote>
<div><p>Individual are identified with an iid, which is a ndarray of two strings: a family ID and a case ID. SNP locations 
are identified with sid string. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</div></blockquote>
<p>When Data is Read:</p>
<blockquote>
<div><p>SNP data can be enormous so generally avoid reading it to the degree practical. Specifically,</p>
<ul>
<li><p class="first">Constructing and printing a SnpReader causes no file reading. For example, these commands read no data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span> <span class="c"># Print the Bed SnpReader specification. No data is read.</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c"># print the subset SnpReader. No data is read.</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2]</span>
</pre></div>
</div>
</li>
<li><p class="first">Properties and methods related to the iids and sids (to the degree practical) read only iid and sid data from the disk,
not SNP value data. Moreover, the iid and sid data is read from file only once. Consider these commands:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># without reading any SNP values data from disk, read the sid and iid data from disk, cache it, and then print the first ten sids.</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#use the cached sid information to find the indexes of &#39;1_10&#39; and &#39;1_13&#39;. (No data is read from disk.)</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</li>
<li><p class="first">The only methods that read SNP values from file are <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> and <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt> (to the degree practical). For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#read all the SNP values from disk, creating a new SnpData instance that keeps these values in memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the SNP value for the iid with index 0 and the sid with index 2. (No data is read from disk.)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</li>
<li><p class="first">If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.
for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># from disk, read the SNP values for the iids with index 3 and 4 AND sids with even numbered indexes.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the SNP value with subset iid index 0 and sid index 2 (corresponding to iid index 3 and sid index 4 in the full data). No data is read from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>When Data is Re-Read and Copied:</p>
<blockquote>
<div><p>Every time you call a SnpReader&#8217;s <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> method, the SnpReader re-reads the SNP value data and returns a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>
(with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values). Likewise, when you call the <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt> method, the SnpReader re-reads
the data and returns a new kernel ndarray.</p>
<p>Here is an example of what not to do, because it causes all the SNP value data to be read twice.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Not recommended because it inefficiently reads all the SNP values twice.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># read all values into a new SnpData, print a SNP value</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># read all values (again) into a second new SnpData, print a SNP value</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Here are two efficient alternatives. First, if all SNP values can all fit in memory, read them once into a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> and then
access that <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> multiple times.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all values into a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print a SNP value from snpdata1&#39;s in-memory ndarray</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print another SNP value from snpdata1&#39;s in-memory ndarray.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Second, if the SNP value data is too large to fit in memory, use subsetting to read only the SNP values of interest from disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define the subset of data and read only that subset from disk.</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define a second subset of data and read only that subset from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Because the in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> class is a kind of SnpReader, you may read from it, too.
Doing so create a new <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> instance containing a copy of the SNP values in a new ndarray.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values from disk into a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the in-memory SNP values use the same memory as themselves? Yes</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># copy all the SNP values into a new ndarray in a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the two ndarrays of in-memory SNP values use the same memory?</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Avoiding Unwanted ndarray Allocations</p>
<blockquote>
<div><p>You may want a subset of SNPs values from an in-memory <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> and you may know that this subset and the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>
can safely share the memory of the ndarray of SNP values. For this case, the <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> has optional parameters called view_ok and order. If you override 
the defaults of &#8220;view_ok=False,order=&#8217;F&#8217;&#8221; with &#8220;view_ok=True,order=&#8217;A&#8217;, the <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> will, if practical, return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original ndarray.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all data from disk into a SnpData with a new ndarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column01</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create SnpData with the data from just the first two SNPs. Sharing memory is OK. The memory may be laid out in any order (that is sid-major and iid-major are both OK).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#print np.may_share_memory(snpdata1.val, column01.val) # Do the two ndarray&#39;s share memory? They could (but currently they won&#39;t)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column201</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create SnpData with the data from three SNPs, permuted. Sharing memory is OK.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">column201</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># Do the two ndarray&#39;s share memory? No, ndarray decided that this indexing was too complex for sharing.</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Creating Subsetting SnpReaders with Indexing</p>
<blockquote>
<div><p>You often don&#8217;t want to read the SNP values for all iids and sids. You can use indexing to create a subsetting SnpReader that
will read only the SNP values of interest.</p>
<p>SnpReaders support the indexing formats supported by ndarray plus two generalizations. Here are examples of indexing with an array
of indexes, with slicing, and with an array of Booleans.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:]</span> <span class="c">#index with an array of indexes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">2 1015</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read just the two rows of interest from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c">#index with a slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_2</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_2</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">300 507</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boolindexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;23_&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">]</span> <span class="c"># create a Boolean index of sids that start &#39;23_&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_3</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,</span><span class="n">boolindexes</span><span class="p">]</span> <span class="c">#index with array of Booleans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_3</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_3</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">300 24</span>
</pre></div>
</div>
<p>The first generalization over with ndarray offers is full indexing on both the iid dimension and the sid dimension, in other words,
full multidimensional indexing. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_4</span><span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c"># index on two dimensions at once</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_4</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_4</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">2 507</span>
</pre></div>
</div>
<p>The second generalization is indexing on a single integer index.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_5</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span> <span class="c">#index with single integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_5</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_5</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">1 1015</span>
</pre></div>
</div>
<p>Indexing is also useful when you have SNP values in memory via a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> index and want to copy a subset of those values.
While you could instead index directly on the <cite>.SnpData.val</cite> ndarray, by indexing on the <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> instance you
also get iid and cid information.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c"># create a copy or view with every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 sids in the subset</span>
<span class="go">[&#39;1_12&#39; &#39;1_10&#39; &#39;1_28&#39; &#39;1_36&#39; &#39;1_4&#39; &#39;1_11&#39; &#39;1_32&#39; &#39;1_9&#39; &#39;1_17&#39; &#39;1_18&#39;]</span>
</pre></div>
</div>
<p>You can apply indexing on top of indexing to specify subsets of subsets of data to read. In this example, 
only the SNP values for every 16th sid is actually read from the disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># These are just SnpReaders, nothing is read from disk yet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_snpreader</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quarter_snpreader</span> <span class="o">=</span> <span class="n">half_snpreader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sixteenth_snpreader</span> <span class="o">=</span> <span class="n">quarter_snpreader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">][:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half of half of half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sixteenth_snpreader</span> <span class="c">#Print the specification of this reader</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[:,::2][:,::2][:,::2][:,::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now we read from disk. Only values for one sid in every 16 will be read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_sixteenth</span> <span class="o">=</span> <span class="n">sixteenth_snpreader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_sixteenth</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">2.0</span>
</pre></div>
</div>
</div></blockquote>
<p>The <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> Method</p>
<blockquote>
<div>By default the <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> returns a ndarray of scipy.float64 laid out in memory in F-contiguous order (iid-index varies the fastest). You may, instead,
ask for scipy.float32 or for C-contiguous order or any order. See <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> for details.</div></blockquote>
<dl class="docutils">
<dt>The <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> Method</dt>
<dd><p class="first">The <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> method, available only on <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, does in-place standardization of the in-memory
SNP data. By default, it applies &#8216;Unit&#8217; standardization, that is: the values for each SNP will have mean zero and standard deviation 1.0.
NaN values are then filled with zero, the mean (consequently, if there are NaN values, the final standard deviation will not be zero.
Note that, for efficiently, this method works in-place, actually changing values in the ndarray. Although it works in place, for convenience
it also returns itself. See <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> for options and details.</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># Prints the specification for this SnpData</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># standardize changes the values in snpdata1.val and changes the specification.</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;),Unit())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># Read and standardize in one expression with only one ndarray allocated.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
</pre></div>
</div>
</dd>
</dl>
<p>The <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt> Method</p>
<blockquote>
<div>The <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt> method, available on any SnpReader, returns a ndarray of size iid_count x iid_count. The returned array has the value
of the (optionally standardized) SNP values transposed and then multiplied with themselves. When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>,
the method can save memory by reading (and standardizing) the data in blocks. See <tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt> for details.</div></blockquote>
<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.iid_count" title="pysnptools.kernelreader.KernelReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.iid0">
<tt class="descname">iid0</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid0" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.iid_count" title="pysnptools.kernelreader.KernelReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.iid0_count">
<tt class="descname">iid0_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid0_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelReader.iid0_to_index">
<tt class="descname">iid0_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid0_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.iid1">
<tt class="descname">iid1</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid1" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.iid_count" title="pysnptools.kernelreader.KernelReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.iid1_count">
<tt class="descname">iid1_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid1_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelReader.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelReader.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.kernelreader.KernelReader.read" title="pysnptools.kernelreader.KernelReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelReader.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelReader.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="kernelreader-kerneldata">
<h3><tt class="xref py py-class docutils literal"><span class="pre">kernelreader.KernelData</span></tt><a class="headerlink" href="#kernelreader-kerneldata" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.kernelreader.KernelData">
<em class="property">class </em><tt class="descclassname">pysnptools.kernelreader.</tt><tt class="descname">KernelData</tt><big>(</big><em>iid=None</em>, <em>iid0=None</em>, <em>iid1=None</em>, <em>val=None</em>, <em>parent_string=''</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelData" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class hold SNP values in-memory along with related iid and sid information.
It is created by calling the <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">SnpReader.read()</span></tt></a> method on another <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a>, for example, <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> for details and examples.</p>
<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.col" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid" title="pysnptools.snpreader.SnpReader.sid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.sid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelData.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelData.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelData.iid_count" title="pysnptools.kernelreader.KernelData.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.iid0">
<tt class="descname">iid0</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid0" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelData.iid_count" title="pysnptools.kernelreader.KernelData.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.iid0_count">
<tt class="descname">iid0_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid0_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelData.iid0_to_index">
<tt class="descname">iid0_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid0_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.iid1">
<tt class="descname">iid1</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid1" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelData.iid_count" title="pysnptools.kernelreader.KernelData.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.iid1_count">
<tt class="descname">iid1_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid1_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelData.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelData.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelData.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelData.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.kernelreader.KernelData.read" title="pysnptools.kernelreader.KernelData.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.row" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid" title="pysnptools.snpreader.SnpReader.iid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.iid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelData.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelData.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelData.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelData.standardize">
<tt class="descname">standardize</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelData.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelData.val">
<tt class="descname">val</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.kernelreader.KernelData.val" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="kernelreader-identity">
<h3><tt class="xref py py-class docutils literal"><span class="pre">kernelreader.Identity</span></tt><a class="headerlink" href="#kernelreader-identity" title="Permalink to this headline">¶</a></h3>
</div>
<div class="section" id="kernelreader-kernelhdf5">
<h3><tt class="xref py py-class docutils literal"><span class="pre">kernelreader.KernelHdf5</span></tt><a class="headerlink" href="#kernelreader-kernelhdf5" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.kernelreader.KernelHdf5">
<em class="property">class </em><tt class="descclassname">pysnptools.kernelreader.</tt><tt class="descname">KernelHdf5</tt><big>(</big><em>filename</em>, <em>block_size=5000</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.create_block">
<tt class="descname">create_block</tt><big>(</big><em>block_size</em>, <em>order</em>, <em>dtype</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.create_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.h5">
<tt class="descname">h5</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.h5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelHdf5.iid_count" title="pysnptools.kernelreader.KernelHdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.iid0">
<tt class="descname">iid0</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid0" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelHdf5.iid_count" title="pysnptools.kernelreader.KernelHdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.iid0_count">
<tt class="descname">iid0_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid0_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.iid0_to_index">
<tt class="descname">iid0_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid0_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.iid1">
<tt class="descname">iid1</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid1" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelHdf5.iid_count" title="pysnptools.kernelreader.KernelHdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.iid1_count">
<tt class="descname">iid1_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid1_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.kernelreader.KernelHdf5.read" title="pysnptools.kernelreader.KernelHdf5.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.read_direct">
<tt class="descname">read_direct</tt><big>(</big><em>val</em>, <em>selection=(slice(None</em>, <em>None</em>, <em>None)</em>, <em>slice(None</em>, <em>None</em>, <em>None))</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.read_direct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelHdf5.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelHdf5.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.kernelreader.KernelHdf5.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>pstdata</em>, <em>dtype='f8'</em>, <em>col_major=True</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelHdf5.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="kernelreader-kernelnpz">
<h3><tt class="xref py py-class docutils literal"><span class="pre">kernelreader.KernelNpz</span></tt><a class="headerlink" href="#kernelreader-kernelnpz" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.kernelreader.KernelNpz">
<em class="property">class </em><tt class="descclassname">pysnptools.kernelreader.</tt><tt class="descname">KernelNpz</tt><big>(</big><em>pstnpz_filename</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelNpz.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelNpz.iid_count" title="pysnptools.kernelreader.KernelNpz.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.iid0">
<tt class="descname">iid0</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid0" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelNpz.iid_count" title="pysnptools.kernelreader.KernelNpz.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.iid0_count">
<tt class="descname">iid0_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid0_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelNpz.iid0_to_index">
<tt class="descname">iid0_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid0_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.iid1">
<tt class="descname">iid1</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid1" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.kernelreader.KernelNpz.iid_count" title="pysnptools.kernelreader.KernelNpz.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.iid1_count">
<tt class="descname">iid1_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid1_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelNpz.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelNpz.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.SnpData.val" title="pysnptools.snpreader.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.kernelreader.KernelNpz.read" title="pysnptools.kernelreader.KernelNpz.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.SnpData" title="pysnptools.snpreader.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.kernelreader.KernelNpz.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelNpz.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.kernelreader.KernelNpz.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.kernelreader.KernelNpz.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>pstdata</em><big>)</big><a class="headerlink" href="#pysnptools.kernelreader.KernelNpz.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pysnptools.util">
<span id="util-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt> Module<a class="headerlink" href="#module-pysnptools.util" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pysnptools.util.create_directory_if_necessary">
<tt class="descclassname">pysnptools.util.</tt><tt class="descname">create_directory_if_necessary</tt><big>(</big><em>name</em>, <em>isfile=True</em><big>)</big><a class="headerlink" href="#pysnptools.util.create_directory_if_necessary" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pysnptools.util.intersect_apply">
<tt class="descclassname">pysnptools.util.</tt><tt class="descname">intersect_apply</tt><big>(</big><em>data_list</em>, <em>sort_by_dataset=True</em><big>)</big><a class="headerlink" href="#pysnptools.util.intersect_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersects and sorts the iids from a list of datasets, returning new version of the datasets with all the same iids in the same order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_list</strong> (<em>list</em>) &#8211; list of datasets</li>
<li><strong>sort_by_dataset</strong> (<em>bool</em>) &#8211; optional, If True (default), the iids are ordered according to the first non-None dataset.
If False, the order is arbitrary, but consistent.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of datasets</p>
</td>
</tr>
</tbody>
</table>
<p>Here are the dataset formats understood and what is returned for each.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Dataset Format</th>
<th class="head">What is Returned</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>None</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>A <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a></td>
<td>A new subsetting <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> with adjusted iid</td>
</tr>
<tr class="row-even"><td>A dictionary with [&#8216;iid&#8217;] and [&#8216;vals&#8217;] keys</td>
<td>The same dictionary but with the iid and vals values adjusted</td>
</tr>
<tr class="row-odd"><td>Tuple of the form (val ndarray, iid list)</td>
<td>A new tuple with the val ndarray and iid list adjusted</td>
</tr>
</tbody>
</table>
<p>If the iids in all the datasets are already the same and in the same order, then the datasets are returned without change.</p>
<p>Notice that only dictionaries are processed in-place. Inputting a <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> returns a new <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> (unless its iids
are already ok). Inputting a tuple returns a new tuple (unless its iids are already ok).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>from pysnptools.snpreader import Bed
from pysnptools.util.pheno import loadOnePhen,loadPhen
&gt;&gt;&gt;
#Create five datasets in different formats
ignore_in = None
snpreader_in = Bed(&#8216;../../tests/datasets/all_chr.maf0.001.N300&#8217;) # Specify SNP data on disk
pheno_dict = loadOnePhen(&#8216;../../tests/datasets/phenSynthFrom22.23.N300.randcidorder.txt&#8217;,missing=&#8221;&#8221;)
cov = loadPhen(&#8216;../../tests/datasets/all_chr.maf0.001.covariates.N300.txt&#8217;,missing=&#8221;&#8221;)
cov_as_tuple_in = (cov[&#8216;vals&#8217;],cov[&#8216;iid&#8217;]) #We could do cov directly, but as an example we make it a tuple.
&gt;&gt;&gt;
# Create five new datasets with consistent iids
ignore_out, snpreader_out, pheno_dict, cov_as_tuple_out = intersect_apply([ignore_in, snpreader_in, pheno_dict, cov_as_tuple_in])
# Print the first five iids from each dataset
print ignore_out, snpreader_out.iid[:5], pheno_dict[&#8216;iid&#8217;][:5], cov_as_tuple_out[1][:5]
None [[&#8216;POP1&#8217; &#8216;0&#8217;]</p>
<blockquote>
<div>[&#8216;POP1&#8217; &#8216;12&#8217;]
[&#8216;POP1&#8217; &#8216;44&#8217;]
[&#8216;POP1&#8217; &#8216;58&#8217;]
[&#8216;POP1&#8217; &#8216;65&#8217;]] [[&#8216;POP1&#8217; &#8216;0&#8217;]
[&#8216;POP1&#8217; &#8216;12&#8217;]
[&#8216;POP1&#8217; &#8216;44&#8217;]
[&#8216;POP1&#8217; &#8216;58&#8217;]
[&#8216;POP1&#8217; &#8216;65&#8217;]] [[&#8216;POP1&#8217; &#8216;0&#8217;]
[&#8216;POP1&#8217; &#8216;12&#8217;]
[&#8216;POP1&#8217; &#8216;44&#8217;]
[&#8216;POP1&#8217; &#8216;58&#8217;]
[&#8216;POP1&#8217; &#8216;65&#8217;]]</div></blockquote>
</dd></dl>

<dl class="function">
<dt id="pysnptools.util.intersect_ids">
<tt class="descclassname">pysnptools.util.</tt><tt class="descname">intersect_ids</tt><big>(</big><em>idslist</em><big>)</big><a class="headerlink" href="#pysnptools.util.intersect_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of 2d string arrays of family and individual ids.
These are intersected.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">indarr, an array of size N x L, where N is the number of
individuals in the intersection, and L is the number of lists in idslist, and which
contains the index to use (in order) such that all people will be identical and in order
across all data sets.</td>
</tr>
</tbody>
</table>
<p>If one of the lists=None, it is ignored (but still has values reported in indarr, all equal to -1),</p>
</dd></dl>

<dl class="function">
<dt id="pysnptools.util.sub_matrix">
<tt class="descclassname">pysnptools.util.</tt><tt class="descname">sub_matrix</tt><big>(</big><em>val</em>, <em>row_index_list</em>, <em>col_index_list</em>, <em>order='A'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em><big>)</big><a class="headerlink" href="#pysnptools.util.sub_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficiently creates a sub-matrix from a 2-D ndarray.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>val</strong> (<em>ndarray</em>) &#8211; The ndarray from which to copy.</li>
<li><strong>row_index_list</strong> (<em>list of integers</em>) &#8211; Tells which rows (and in which order) to copy into the sub-matrix</li>
<li><strong>col_index_list</strong> (<em>list of integers</em>) &#8211; Tells which columns (and in which order) to copy into the sub-matrix</li>
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;A&#8217; (default), &#8216;C&#8217;, &#8216;F&#8217;}, optional &#8211; Specify the order of the sub-matrix to create.
If order is &#8216;C&#8217;, then the returned sub-matrix will be in C-contiguous order (first index varies the fastest).
If order is &#8216;F&#8217;, then the array will be in F-contiguous order (second index varies the fastest).
If order is &#8216;A&#8217;, then sub-matrix may be in any order F or C.</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for sub-matrix created.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray</p>
</td>
</tr>
</tbody>
</table>
<p>import numpy as np
import pysnptools.util as pstutil
np.random.seed(0) # set seed so that results are deterministic
matrix = np.random.rand(12,7) # create a 12 x 7 ndarray
submatrix = pstutil.sub_matrix(matrix,[0,2,11],[6,5,4,3,2,1,0])
print (int(submatrix.shape[0]),int(submatrix.shape[1]))
(3, 7)
print matrix[2,0] == submatrix[1,6] #The row # 2 is now #1, the column #0 is now #6.
True</p>
<p>Note: Behind the scenes, for performance, this function selects and then calls one of 16 C++ helper functions.</p>
</dd></dl>

<dl class="function">
<dt id="pysnptools.util.weighted_mean">
<tt class="descclassname">pysnptools.util.</tt><tt class="descname">weighted_mean</tt><big>(</big><em>ys</em>, <em>weights</em><big>)</big><a class="headerlink" href="#pysnptools.util.weighted_mean" title="Permalink to this definition">¶</a></dt>
<dd><p>ys = np.array([103.664086,89.80645161,83.86888046,90.54141176])
weights = np.array([2.340862423,4.982888433,0.17522245,0.098562628])
round(weighted_mean(ys, weights),5)
93.9487</p>
</dd></dl>

<dl class="function">
<dt id="pysnptools.util.weighted_simple_linear_regression">
<tt class="descclassname">pysnptools.util.</tt><tt class="descname">weighted_simple_linear_regression</tt><big>(</big><em>xs</em>, <em>ys</em>, <em>weights</em><big>)</big><a class="headerlink" href="#pysnptools.util.weighted_simple_linear_regression" title="Permalink to this definition">¶</a></dt>
<dd><p>xs = np.array([53.8329911,57.49486653,60.07392197,60.21081451])
ys = np.array([103.664086,89.80645161,83.86888046,90.54141176])
weights = np.array([2.340862423,4.982888433,0.17522245,0.098562628])
slope, intercept, xmean, ymean = weighted_simple_linear_regression(xs, ys, weights)
print round(slope,5), round(intercept,5), round(xmean,5), round(ymean,5)
-3.52643 293.05586 56.46133 93.9487</p>
</dd></dl>

<div class="section" id="util-intrangeset">
<h3><tt class="xref py py-class docutils literal"><span class="pre">util.IntRangeSet</span></tt><a class="headerlink" href="#util-intrangeset" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.util.IntRangeSet">
<em class="property">class </em><tt class="descclassname">pysnptools.util.</tt><tt class="descname">IntRangeSet</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A class for efficiently manipulating ranges of integers (including negatives and longs) using set operations such as <a class="reference internal" href="#pysnptools.util.IntRangeSet.union" title="pysnptools.util.IntRangeSet.union"><tt class="xref py py-meth docutils literal"><span class="pre">union()</span></tt></a>, <a class="reference internal" href="#pysnptools.util.IntRangeSet.intersection" title="pysnptools.util.IntRangeSet.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">intersection()</span></tt></a>, and difference.</p>
<p>The class differs from the built-in <em>set</em> class (and from Boolean numpy arrays) because it does need memory for every element in the set, only for every contiguous range of elements.
It differs from other Python interval libraries (that we know of) by being specialized and optimized for integer elements.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Here we take the union (operator &#8220;|&#8221;) of two IntRangeSets:</p>
<img alt="_images/example1.png" src="_images/example1.png" />
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&quot;100:500,501:1000&quot;</span><span class="p">)</span> <span class="c"># a is the set of integers from 100 to 500 (exclusive) and 501 to 1000 (exclusive)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&quot;-20,400:600&quot;</span><span class="p">)</span>      <span class="c"># b is the set of integers -20 and the range 400 to 600 (exclusive)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">|</span> <span class="n">b</span>                           <span class="c"># c is the union of a and b, namely -20 and 100 to 1000 (exclusive)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">c</span>
<span class="go">IntRangeSet(&#39;-20,100:1000&#39;)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Suppose we want to find the intron regions of a gene but we are given only the transcription region and the exon regions.</p>
<img alt="_images/example2.png" src="_images/example2.png" />
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.util</span> <span class="kn">import</span> <span class="n">IntRangeSet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">line</span> <span class="o">=</span> <span class="s">&quot;chr15   29370   37380   29370,32358,36715   30817,32561,37380&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">chr</span><span class="p">,</span><span class="n">trans_start</span><span class="p">,</span><span class="n">trans_last</span><span class="p">,</span><span class="n">exon_starts</span><span class="p">,</span><span class="n">exon_lasts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span> <span class="c"># split the line on white space</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">trans_start</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">trans_stop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">trans_last</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c"># add one to convert the inclusive &quot;last&quot; value into a Pythonesque exclusive &quot;stop&quot; value</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_range_set</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">((</span><span class="n">trans_start</span><span class="p">,</span><span class="n">trans_stop</span><span class="p">))</span> <span class="c"># creates a IntRangeSet from 29370 (inclusive) to 37381 (exclusive)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">int_range_set</span> <span class="c"># print at any time to see the current value</span>
<span class="go">IntRangeSet(&#39;29370:37381&#39;)</span>
</pre></div>
</div>
<p>Parse the exon start and last lists from strings to lists of integers (converting &#8216;last&#8217; to &#8216;stop&#8217;)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">exon_starts</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">exon_starts</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">exon_stops</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">last</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span> <span class="k">for</span> <span class="n">last</span> <span class="ow">in</span> <span class="n">exon_lasts</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s">&quot;,&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s">&#39;,&#39;</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">exon_starts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">exon_stops</span><span class="p">)</span>
</pre></div>
</div>
<p>Zip together the two lists to create an iterable of exon_start,exon_stop tuples. Then
&#8216;set subtract&#8217; all these ranges from int_range_set</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_range_set</span> <span class="o">-=</span> <span class="n">izip</span><span class="p">(</span><span class="n">exon_starts</span><span class="p">,</span><span class="n">exon_stops</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">int_range_set</span> <span class="c"># See what it looks like</span>
<span class="go">IntRangeSet(&#39;30818:32358,32562:36715&#39;)</span>
</pre></div>
</div>
<p>Create the desired output by iterating through each contiguous range of integers</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span> <span class="ow">in</span> <span class="n">int_range_set</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="s">&quot;{0}   {1}     {2}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">chr</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="go">chr15   30818     32357</span>
<span class="go">chr15   32562     36714</span>
</pre></div>
</div>
<p><strong>Ranges Input</strong></p>
<p>The input to the <a class="reference internal" href="#pysnptools.util.IntRangeSet" title="pysnptools.util.IntRangeSet"><tt class="xref py py-class docutils literal"><span class="pre">IntRangeSet</span></tt></a> constructor and many of its methods is a <em>ranges input</em>.</p>
<p>A <em>ranges input</em> is one of the following:</p>
<blockquote>
<div><ul class="simple">
<li>A comma-separated string of integers or integer ranges, e.g., <tt class="docutils literal"><span class="pre">'100:500,500:1000,2000'</span></tt></li>
<li>An integer or integer expression, e.g., <tt class="docutils literal"><span class="pre">3</span></tt></li>
<li>A tuple of two integers, <em>start</em> and <em>stop</em>, e.g., <tt class="docutils literal"><span class="pre">(2,8)</span></tt>. <em>stop</em> is exclusive.</li>
<li>A slice with non-negative values, e.g. <tt class="docutils literal"><span class="pre">slice(2,8)</span></tt></li>
<li>A <a class="reference internal" href="#pysnptools.util.IntRangeSet" title="pysnptools.util.IntRangeSet"><tt class="xref py py-class docutils literal"><span class="pre">IntRangeSet</span></tt></a> (or any class with a <a class="reference internal" href="#pysnptools.util.IntRangeSet.ranges" title="pysnptools.util.IntRangeSet.ranges"><tt class="xref py py-meth docutils literal"><span class="pre">ranges()</span></tt></a> method), e.g., <tt class="docutils literal"><span class="pre">IntRangeSet(3)</span></tt></li>
<li>A list or iterable (but not tuple) of <em>ranges inputs</em>, e.g., <tt class="docutils literal"><span class="pre">[1,6,7,(100,200)]</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Strings:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&quot;100:500,500:1000,2000&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;-10:-8,1,2,3:11&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>The ranges in an <em>ranges input</em> can overlap and can be in any order.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&quot;2000,100:1500,500:1000,2000&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:1500,2000&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Integers and Integer Expressions:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">151000000000</span><span class="p">)</span> <span class="c"># longs are OK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="c"># integer expressions are OK</span>
</pre></div>
</div>
<p>A tuple must have exactly two integers. They represent the <em>start</em> (inclusive) and <em>stop</em> (exclusive) integers in a range.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;2:8&#39;</span><span class="p">)</span> <span class="c"># check &#39;set equality&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="mi">7</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span> <span class="c"># The integer 7 is an element of the set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Lists and iterables of <em>ranges inputs</em>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">,(</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">)])</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;1,6:8,100:200&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">100</span><span class="p">))</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:100&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">([</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">200</span><span class="p">),</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;1000:2000&#39;</span><span class="p">,[</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">],(</span><span class="mi">20</span><span class="p">,</span><span class="mi">30</span><span class="p">)])</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;3:5,6,20:30,100:200,1000:2000&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Some methods accept zero or more <em>ranges input</em> as their input. This is called a <em>*ranges_inputs</em>. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">()</span> <span class="c"># zero ranges inputs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="c"># one ranges input</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;3:11,5&#39;</span><span class="p">,</span><span class="mi">14</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span> <span class="c"># Three ranges inputs, a string and two integers.</span>
</pre></div>
</div>
</div></blockquote>
<p><strong>Most Important Methods and Operators</strong></p>
<table border="1" class="docutils">
<colgroup>
<col width="38%" />
<col width="38%" />
<col width="24%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><em>Description</em></td>
<td><em>Method or Operator</em></td>
<td><em>For Details</em></td>
</tr>
<tr class="row-even"><td>is a &#8216;set equal&#8217; to b?</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__eq__" title="pysnptools.util.IntRangeSet.__eq__"><tt class="xref py py-meth docutils literal"><span class="pre">__eq__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>is a is superset of b?</td>
<td><tt class="docutils literal"><span class="pre">b</span> <span class="pre">in</span> <span class="pre">a</span></tt>,
<tt class="docutils literal"><span class="pre">a.issuperset(b)</span></tt>,
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__contains__" title="pysnptools.util.IntRangeSet.__contains__"><tt class="xref py py-meth docutils literal"><span class="pre">__contains__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>is a is subset of b?</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a.issubset(b)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__le__" title="pysnptools.util.IntRangeSet.__le__"><tt class="xref py py-meth docutils literal"><span class="pre">__le__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>remove <em>i</em> th smallest element(s)</td>
<td><tt class="docutils literal"><span class="pre">del</span> <span class="pre">a[i]</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__delitem__" title="pysnptools.util.IntRangeSet.__delitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__delitem__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>get <em>i</em> th smallest element(s)</td>
<td><tt class="docutils literal"><span class="pre">a[i]</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__getitem__" title="pysnptools.util.IntRangeSet.__getitem__"><tt class="xref py py-meth docutils literal"><span class="pre">__getitem__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>is a not &#8216;set equal&#8217; to b?</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__ne__" title="pysnptools.util.IntRangeSet.__ne__"><tt class="xref py py-meth docutils literal"><span class="pre">__ne__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>is a is proper superset of b?</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__gt__" title="pysnptools.util.IntRangeSet.__gt__"><tt class="xref py py-meth docutils literal"><span class="pre">__gt__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>is a is proper subset of b?</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__lt__" title="pysnptools.util.IntRangeSet.__lt__"><tt class="xref py py-meth docutils literal"><span class="pre">__lt__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>union b into a</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|=</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a.add(b,c)</span></tt>,
<tt class="docutils literal"><span class="pre">a.update(b,c)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.add" title="pysnptools.util.IntRangeSet.add"><tt class="xref py py-meth docutils literal"><span class="pre">add()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>union a and b</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a.union(b,c)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__or__" title="pysnptools.util.IntRangeSet.__or__"><tt class="xref py py-meth docutils literal"><span class="pre">__or__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>intersect b into a</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&amp;=</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a.intersection_update(b,c)</span></tt>,</td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__iand__" title="pysnptools.util.IntRangeSet.__iand__"><tt class="xref py py-meth docutils literal"><span class="pre">__iand__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>intersect a and b</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a.intersection(b,c)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.intersection" title="pysnptools.util.IntRangeSet.intersection"><tt class="xref py py-meth docutils literal"><span class="pre">intersection()</span></tt></a></td>
</tr>
<tr class="row-even"><td>subtract b from in a</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">-=</span> <span class="pre">b</span></tt>,
<tt class="docutils literal"><span class="pre">a.difference_update(b)</span></tt>,
<tt class="docutils literal"><span class="pre">a.discard(b)</span></tt>,</td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__isub__" title="pysnptools.util.IntRangeSet.__isub__"><tt class="xref py py-meth docutils literal"><span class="pre">__isub__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>remove b from a, error if missing</td>
<td><tt class="docutils literal"><span class="pre">a.remove(b)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.remove" title="pysnptools.util.IntRangeSet.remove"><tt class="xref py py-meth docutils literal"><span class="pre">remove()</span></tt></a></td>
</tr>
<tr class="row-even"><td>a &#8216;set difference&#8217; b</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span></tt>
<tt class="docutils literal"><span class="pre">a.difference(b)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__sub__" title="pysnptools.util.IntRangeSet.__sub__"><tt class="xref py py-meth docutils literal"><span class="pre">__sub__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>iterate integers in a, from low</td>
<td><tt class="docutils literal"><span class="pre">for</span> <span class="pre">element</span> <span class="pre">in</span> <span class="pre">a:</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__iter__" title="pysnptools.util.IntRangeSet.__iter__"><tt class="xref py py-meth docutils literal"><span class="pre">__iter__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>iterate integers in a, from high</td>
<td><tt class="docutils literal"><span class="pre">for</span> <span class="pre">element</span> <span class="pre">in</span> <span class="pre">reverse(a):</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__reversed__" title="pysnptools.util.IntRangeSet.__reversed__"><tt class="xref py py-meth docutils literal"><span class="pre">__reversed__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>symmetric difference into a</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">^=</span> <span class="pre">b</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__ixor__" title="pysnptools.util.IntRangeSet.__ixor__"><tt class="xref py py-meth docutils literal"><span class="pre">__ixor__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>a &#8216;symmetric difference&#8217; b</td>
<td><tt class="docutils literal"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">b</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__xor__" title="pysnptools.util.IntRangeSet.__xor__"><tt class="xref py py-meth docutils literal"><span class="pre">__xor__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>count of integer elements in a</td>
<td><tt class="docutils literal"><span class="pre">len(a)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__len__" title="pysnptools.util.IntRangeSet.__len__"><tt class="xref py py-meth docutils literal"><span class="pre">__len__()</span></tt></a></td>
</tr>
<tr class="row-even"><td>iterate ranges in a, from low</td>
<td><tt class="docutils literal"><span class="pre">for</span> <span class="pre">start,stop</span> <span class="pre">in</span> <span class="pre">a.ranges():</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.ranges" title="pysnptools.util.IntRangeSet.ranges"><tt class="xref py py-meth docutils literal"><span class="pre">ranges()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>count of ranges in a</td>
<td><tt class="docutils literal"><span class="pre">a.ranges_len</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.ranges_len" title="pysnptools.util.IntRangeSet.ranges_len"><tt class="xref py py-meth docutils literal"><span class="pre">ranges_len()</span></tt></a></td>
</tr>
<tr class="row-even"><td>index of range containing b</td>
<td><tt class="docutils literal"><span class="pre">a.ranges_index(b)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.ranges_index" title="pysnptools.util.IntRangeSet.ranges_index"><tt class="xref py py-meth docutils literal"><span class="pre">ranges_index()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>get <a href="#id1"><span class="problematic" id="id2">*</span></a>i*th smallest range</td>
<td><tt class="docutils literal"><span class="pre">a.ranges_getitem(i)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.ranges_getitem" title="pysnptools.util.IntRangeSet.ranges_getitem"><tt class="xref py py-meth docutils literal"><span class="pre">ranges_getitem()</span></tt></a></td>
</tr>
<tr class="row-even"><td>a as a string</td>
<td><tt class="docutils literal"><span class="pre">str(a)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.__str__" title="pysnptools.util.IntRangeSet.__str__"><tt class="xref py py-meth docutils literal"><span class="pre">__str__()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>remove all elements from a</td>
<td><tt class="docutils literal"><span class="pre">a.clear()</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.clear" title="pysnptools.util.IntRangeSet.clear"><tt class="xref py py-meth docutils literal"><span class="pre">clear()</span></tt></a></td>
</tr>
<tr class="row-even"><td>copy a</td>
<td><tt class="docutils literal"><span class="pre">a.copy()</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.copy" title="pysnptools.util.IntRangeSet.copy"><tt class="xref py py-meth docutils literal"><span class="pre">copy()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>find index of b in a</td>
<td><tt class="docutils literal"><span class="pre">a.index(b)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.index" title="pysnptools.util.IntRangeSet.index"><tt class="xref py py-meth docutils literal"><span class="pre">index()</span></tt></a></td>
</tr>
<tr class="row-even"><td>are a and b disjoint?</td>
<td><tt class="docutils literal"><span class="pre">a.isdisjoint(b)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.isdisjoint" title="pysnptools.util.IntRangeSet.isdisjoint"><tt class="xref py py-meth docutils literal"><span class="pre">isdisjoint()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>is a empty?</td>
<td><tt class="docutils literal"><span class="pre">a.isempty(b)</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.isempty" title="pysnptools.util.IntRangeSet.isempty"><tt class="xref py py-meth docutils literal"><span class="pre">isempty()</span></tt></a></td>
</tr>
<tr class="row-even"><td>smallest element of a</td>
<td><tt class="docutils literal"><span class="pre">a.min()</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.min" title="pysnptools.util.IntRangeSet.min"><tt class="xref py py-meth docutils literal"><span class="pre">min()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>largest element of a</td>
<td><tt class="docutils literal"><span class="pre">a.max()</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.max" title="pysnptools.util.IntRangeSet.max"><tt class="xref py py-meth docutils literal"><span class="pre">max()</span></tt></a></td>
</tr>
<tr class="row-even"><td>sum of elements in a</td>
<td><tt class="docutils literal"><span class="pre">a.sum()</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.sum" title="pysnptools.util.IntRangeSet.sum"><tt class="xref py py-meth docutils literal"><span class="pre">sum()</span></tt></a></td>
</tr>
<tr class="row-odd"><td>remove and return an element</td>
<td><tt class="docutils literal"><span class="pre">a.pop()</span></tt></td>
<td><a class="reference internal" href="#pysnptools.util.IntRangeSet.pop" title="pysnptools.util.IntRangeSet.pop"><tt class="xref py py-meth docutils literal"><span class="pre">pop()</span></tt></a></td>
</tr>
</tbody>
</table>
<p><strong>Examples, Tips, and Warnings</strong></p>
<p>The argument to a method and the right-hand side of an operator can be a <em>ranges input</em> rather than <a class="reference internal" href="#pysnptools.util.IntRangeSet" title="pysnptools.util.IntRangeSet"><tt class="xref py py-class docutils literal"><span class="pre">IntRangeSet</span></tt></a>. For example,</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">big</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;-1000:2000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">big</span> <span class="o">-</span> <span class="s">&#39;10:20,500&#39;</span> <span class="c"># We can subtract this string because it is a legal ranges input.</span>
<span class="go">IntRangeSet(&#39;-1000:10,20:500,501:2000&#39;)</span>
</pre></div>
</div>
<p>This even works for equality testing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">big</span> <span class="o">-</span> <span class="s">&#39;10:21,500&#39;</span> <span class="o">==</span> <span class="s">&#39;-1000:10,21:500,501:2000&#39;</span>
</pre></div>
</div>
<p>The Python <em>in</em> operator is backwards from other operators, so the left-hand side can be any <em>ranges input</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="mi">501</span> <span class="ow">in</span> <span class="n">big</span>
</pre></div>
</div>
</div></blockquote>
<p>Like most other Python libraries you specify a range with an inclusive <em>start</em> integer and an exclusive <em>stop</em>.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mi">7</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;4:8&#39;</span><span class="p">)</span> <span class="c"># includes 7</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mi">8</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;4:8&#39;</span><span class="p">)</span> <span class="c"># excludes 8</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mi">8</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="nb">xrange</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">))</span> <span class="c"># also excludes 8</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="docutils">
<dt>Be careful with the <em>ranges inputs</em> specified with tuples. Suppose we want a <a class="reference internal" href="#pysnptools.util.IntRangeSet" title="pysnptools.util.IntRangeSet"><tt class="xref py py-class docutils literal"><span class="pre">IntRangeSet</span></tt></a> containing 4,5,6,7.</dt>
<dd><div class="first last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">((</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">))</span> <span class="o">==</span> <span class="s">&#39;4:8&#39;</span> <span class="c">#OK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">([(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)])</span> <span class="o">==</span> <span class="s">&#39;4:8&#39;</span> <span class="c"># List of a tuple is OK</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;4,8&#39;</span> <span class="c">#No. This is not a tuple. It is two integer inputs, so we get only 4 and 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">IntRangeSet</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span><span class="mi">8</span><span class="p">])</span> <span class="o">==</span> <span class="s">&#39;4,8&#39;</span> <span class="c">#No. List of two integers, so get only 4 and 8</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#Illegal: IntRangeSet((4,8,10)) # tuples must be pairs</span>
</pre></div>
</div>
</dd>
</dl>
<p><strong>Methods and Operators</strong></p>
<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__contains__">
<tt class="descname">__contains__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__contains__" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when all the ranges input is a subset of the IntRangeSet.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">b</span> <span class="pre">in</span> <span class="pre">a</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.issuperset(b)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;4:7&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;6:9&#39;</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="c"># The left-hand of &#39;in&#39; can be any ranges input</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">&#39;6:9&#39;</span> <span class="c"># The right-hand of can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The &#8216;issuperset&#8217; method also supports unioning multiple ranges inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note: By definition, any set is a superset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__delitem__">
<tt class="descname">__delitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__delitem__" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove elements from the IntRangeSet by position index. Position index can be specified by an integer with
negative integers counting from the end. Position indexes can also be specified with slices and a ranges input.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Removing with an integer position index:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;100:102,103:200,1000&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;100:102,103:200&#39;)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Removing with a slice:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">11</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;100:102,111:200,1000&#39;)</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<p>Removing with a ranges input:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span><span class="p">[</span><span class="s">&#39;2:11&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;100:102,111:200,1000&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__eq__">
<tt class="descname">__eq__</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__eq__" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet on the left is <em>set equivalent</em> to the ranges input on the right.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt></li>
</ul>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;12,0:5,5:10&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="s">&#39;0:10,12&#39;</span> <span class="c"># The right-hand can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__ge__">
<tt class="descname">__ge__</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__ge__" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.util.IntRangeSet.__contains__" title="pysnptools.util.IntRangeSet.__contains__"><tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet.__contains__()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__getitem__">
<tt class="descname">__getitem__</tt><big>(</big><em>key</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__getitem__" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">a[i]</span></tt> returns the ith integer in sorted order (origin 0) from a, an IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
<span class="go">100</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)[</span><span class="mi">10</span><span class="p">]</span>
<span class="go">110</span>
</pre></div>
</div>
<p>If i is negative, the indexing goes from the end</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="go">1000</span>
</pre></div>
</div>
<p>Python&#8217;s standard slice notation may be used and returns IntRangeSets.
(Remember that the Stop number in slice notation is exclusive.)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># Integers 0 (inclusive) to 10 (exclusive)</span>
<span class="go">IntRangeSet(&#39;100:110&#39;)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">:</span><span class="mi">10</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Integers 0 (inclusive) to 10 (exclusive) with step 2</span>
<span class="go">IntRangeSet(&#39;100,102,104,106,108&#39;)</span>
</pre></div>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)[</span><span class="o">-</span><span class="mi">3</span><span class="p">:]</span> <span class="c"># The last three integers in the IntRangeSet.</span>
<span class="go">IntRangeSet(&#39;198:200,1000&#39;)</span>
</pre></div>
</div>
<p>An IntRangeSet can also be accessed with any ranges input.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:200,1000&#39;</span><span class="p">)[</span><span class="s">&#39;0:10,20&#39;</span><span class="p">]</span>
<span class="go">IntRangeSet(&#39;100:110,120&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__gt__">
<tt class="descname">__gt__</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__gt__" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet is a proper superset of the ranges.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;</span> <span class="pre">b</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="s">&#39;7:10&#39;</span> <span class="c"># The right-hand can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: By definition, no set is a proper superset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__iadd__">
<tt class="descname">__iadd__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__iadd__" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.util.IntRangeSet.add" title="pysnptools.util.IntRangeSet.add"><tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet.add()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__iand__">
<tt class="descname">__iand__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__iand__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the IntRangeSet to itself intersected with a input range</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&amp;=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.intersection_update(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">&amp;=</span> <span class="s">&#39;3:8&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;3:5,6:8&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__imul__">
<tt class="descname">__imul__</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__imul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Put produces n copies of a unioned together in a, where a is an IntRangeSet.
Because a is a set, the result will either be an empty IntRangeSet (n is 0 or less) or the original a.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">*=</span> <span class="pre">n</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span> <span class="c"># should be unchanged</span>
<span class="go">IntRangeSet(&#39;0:5,6:11&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">*=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span> <span class="c"># should be empty</span>
<span class="go">IntRangeSet(&#39;&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__init__">
<tt class="descname">__init__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <a class="reference internal" href="#pysnptools.util.IntRangeSet" title="pysnptools.util.IntRangeSet"><tt class="xref py py-class docutils literal"><span class="pre">IntRangeSet</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__ior__">
<tt class="descname">__ior__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__ior__" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.util.IntRangeSet.add" title="pysnptools.util.IntRangeSet.add"><tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet.add()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__isub__">
<tt class="descname">__isub__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__isub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove the elements of the range inputs from the IntRangeSet</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">-=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.difference_update(b)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.discard(b)</span></tt></li>
</ul>
<p><tt class="docutils literal"><span class="pre">remove</span></tt> is almost the same except that it raises a KeyError if any element of b is not in a.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a.remove(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">-=</span> <span class="s">&#39;3:7&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:3,7:11&#39;)</span>
</pre></div>
</div>
<p>The &#8216;difference_update&#8217;, &#8216;discard&#8217; and &#8216;remove&#8217; methods also support subtracting multiple ranges inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">difference_update</span><span class="p">(</span><span class="s">&#39;3:7&#39;</span><span class="p">,</span><span class="s">&#39;8:100&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:3,7&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__iter__">
<tt class="descname">__iter__</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__iter__" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate, in order from smallest to largest, the integer elements of the IntRangeSet</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;1:4,10&#39;</span><span class="p">):</span>
<span class="gp">... </span>   <span class="k">print</span> <span class="n">i</span>
<span class="go">1</span>
<span class="go">2</span>
<span class="go">3</span>
<span class="go">10</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__ixor__">
<tt class="descname">__ixor__</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__ixor__" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the IntRangeSet to contains exactly those elements that appear in either itself or the input ranges but not both</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">^=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.symmetric_difference_update(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">^=</span> <span class="s">&#39;3:8&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:3,5,8:11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__le__">
<tt class="descname">__le__</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__le__" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet is a subset of the ranges.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.issubset(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="s">&#39;-1:101&#39;</span> <span class="c"># The right-hand can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: By definition, any set is a subset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__len__">
<tt class="descname">__len__</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__len__" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of integer elements in the IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">len</span><span class="p">(</span><span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">))</span>
<span class="go">11</span>
</pre></div>
</div>
<p>Note: This is computed in time linear in the number of ranges, rather than integer elements.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__lt__">
<tt class="descname">__lt__</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__lt__" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet is a proper subset of the ranges.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;</span> <span class="pre">b</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">&lt;</span> <span class="s">&#39;-1:101&#39;</span> <span class="c"># The right-hand can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: By definition, no set is a proper subset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__mul__">
<tt class="descname">__mul__</tt><big>(</big><em>n</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">n</span></tt>, produces n shallow copies of a unioned, where a is an IntRangeSet.
Because a is a set, the result will either be an empty IntRangeSet (n is 0 or less) or a copy of
the original IntRangeSet.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">*</span> <span class="pre">n</span></tt></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__ne__">
<tt class="descname">__ne__</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__ne__" title="Permalink to this definition">¶</a></dt>
<dd><p><em>False</em> exactly when the IntRangeSet on the left is <em>set equivalent</em> to the ranges input on the right.</p>
<p>These are the same.</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">!=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">not</span> <span class="pre">a</span> <span class="pre">==</span> <span class="pre">b</span></tt></li>
</ul>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__or__">
<tt class="descname">__or__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__or__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the union of a IntRangeSet with zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.union(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="mi">5</span>
<span class="go">IntRangeSet(&#39;0:10&#39;)</span>
</pre></div>
</div>
<p>The &#8216;union&#8217; method also support unioning multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;100:200&#39;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0:10,100:200&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__repr__">
<tt class="descname">__repr__</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__repr__" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the standard repr(a) function to create a string representation of a, an IntRangeSet.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Hello &quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Hello IntRangeSet(&#39;2:5,10&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__reversed__">
<tt class="descname">__reversed__</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__reversed__" title="Permalink to this definition">¶</a></dt>
<dd><p>reversed(a) is a generator that produces the integer elements of a in order from largest to smallest.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;1:4,10&#39;</span><span class="p">)):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">i</span>
<span class="go">10</span>
<span class="go">3</span>
<span class="go">2</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__str__">
<tt class="descname">__str__</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__str__" title="Permalink to this definition">¶</a></dt>
<dd><p>Use the standard str(a) function to create a string representation of a, an IntRangeSet.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="s">&quot;Hello &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="go">Hello IntRangeSet(&#39;2:5,10&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__sub__">
<tt class="descname">__sub__</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set difference of a IntRangeSet with zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.difference(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">IntRangeSet(&#39;0,2:5,6:11&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="s">&#39;3:100&#39;</span>
<span class="go">IntRangeSet(&#39;0:3&#39;)</span>
</pre></div>
</div>
<p>The &#8216;difference&#8217; method also supports subtracting multiple input ranges</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="s">&#39;3:100&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0,2&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.__xor__">
<tt class="descname">__xor__</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.__xor__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new IntRangeSet set with elements in either the input IntRangeSet or the input range but not both.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.symmetric_difference(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">^</span> <span class="s">&#39;3:9&#39;</span>
<span class="go">IntRangeSet(&#39;0:3,5,9:11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.add">
<tt class="descname">add</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Union zero or more ranges inputs into the current IntRangeSet.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.add(b)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.update(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">|=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:10&#39;)</span>
</pre></div>
</div>
<p>The &#8216;add&#8217; and &#8216;update&#8217; methods also support unioning multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;5&#39;</span><span class="p">,</span><span class="s">&#39;100:200&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:10,100:200&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all ranges from this IntRangeSet.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deep copy of a IntRangeSet.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.count">
<tt class="descname">count</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of times that the elements of ranges appears in the IntRangeSet. Because IntRangeSet is 
a set, the number will be either 0 or 1.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;105:107,1000&#39;</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.difference">
<tt class="descname">difference</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set difference of a IntRangeSet with zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.difference(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">IntRangeSet(&#39;0,2:5,6:11&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="s">&#39;3:100&#39;</span>
<span class="go">IntRangeSet(&#39;0:3&#39;)</span>
</pre></div>
</div>
<p>The &#8216;difference&#8217; method also supports subtracting multiple input ranges</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="s">&#39;3:100&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0,2&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.difference_update">
<tt class="descname">difference_update</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.difference_update" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.util.IntRangeSet.__isub__" title="pysnptools.util.IntRangeSet.__isub__"><tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet.__isub__()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.discard">
<tt class="descname">discard</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.discard" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.util.IntRangeSet.__isub__" title="pysnptools.util.IntRangeSet.__isub__"><tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet.__isub__()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.index">
<tt class="descname">index</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.index" title="Permalink to this definition">¶</a></dt>
<dd><p>If x is an integer, returns the index of x in a, where a is an IntRangeSet.
If x is an ranges input, returns an IntRangeSet of index of every integer in x.
Raises an IndexError is x not in a.</p>
<p><tt class="docutils literal"><span class="pre">*</span> <span class="pre">a.index(x)</span></tt></p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">109</span><span class="p">)</span>
<span class="go">9</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;109,100:104&#39;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0:4,9&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.intersection">
<tt class="descname">intersection</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of a IntRangeSet and zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.intersection(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="s">&#39;3:8&#39;</span>
<span class="go">IntRangeSet(&#39;3:5,6:8&#39;)</span>
</pre></div>
</div>
<p>The &#8216;intersection&#8217; method also support intersecting multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="s">&#39;3:8&#39;</span><span class="p">,</span><span class="s">&#39;4:7&#39;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;4,6&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.intersection_update">
<tt class="descname">intersection_update</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.intersection_update" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.util.IntRangeSet.__iand__" title="pysnptools.util.IntRangeSet.__iand__"><tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet.__iand__()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.isdisjoint">
<tt class="descname">isdisjoint</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.isdisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the two sets have no integer elements in common.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="s">&#39;900:2000&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100:110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="s">&#39;1900:2000&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.util.IntRangeSet.isempty">
<tt class="descname">isempty</tt><a class="headerlink" href="#pysnptools.util.IntRangeSet.isempty" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet is empty.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">()</span><span class="o">.</span><span class="n">isempty</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.issubset">
<tt class="descname">issubset</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.issubset" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet is a subset of the ranges.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.issubset(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="s">&#39;-1:101&#39;</span> <span class="c"># The right-hand can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: By definition, any set is a subset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.issuperset">
<tt class="descname">issuperset</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.issuperset" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when all the ranges input is a subset of the IntRangeSet.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">b</span> <span class="pre">in</span> <span class="pre">a</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.issuperset(b)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;4:7&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;6:9&#39;</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="c"># The left-hand of &#39;in&#39; can be any ranges input</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">&#39;6:9&#39;</span> <span class="c"># The right-hand of can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The &#8216;issuperset&#8217; method also supports unioning multiple ranges inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note: By definition, any set is a superset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.max">
<tt class="descname">max</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.max" title="Permalink to this definition">¶</a></dt>
<dd><p>The largest integer element in the IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Note: This is more efficient than max(IntRangeSet(&#8216;0:10,12&#8217;)) because is computed
in constant time rather than in time linear to the number of integer elements.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.min">
<tt class="descname">min</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.min" title="Permalink to this definition">¶</a></dt>
<dd><p>The smallest integer element in the IntRangeSet</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Note: This is more efficient than <tt class="docutils literal"><span class="pre">min(IntRangeSet('0:10,12'))</span></tt> because is computed
in constant time rather than in time linear to the number of integer elements.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.pop">
<tt class="descname">pop</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove and return the largest integer element from the IntRangeSet. Raises KeyError if the IntRangeSet is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:5,6:10&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.ranges">
<tt class="descname">ranges</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate, in order, the ranges of a IntRangeSet as (start,stop) tuples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">start</span><span class="p">,</span><span class="n">stop</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,100:200&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
<span class="gp">... </span>      <span class="k">print</span> <span class="s">&quot;start is {0}, stop is {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">stop</span><span class="p">)</span>
<span class="go">start is 0, stop is 10</span>
<span class="go">start is 100, stop is 200</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.ranges_getitem">
<tt class="descname">ranges_getitem</tt><big>(</big><em>index</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.ranges_getitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the index-th range in the collection of ranges</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;-30:-20,0:10,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ranges_getitem</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">(0, 10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.ranges_index">
<tt class="descname">ranges_index</tt><big>(</big><em>element</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.ranges_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the ranges index of range containing the element</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">int_range_set</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;-30:-20,0:10,12&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">index</span> <span class="o">=</span> <span class="n">int_range_set</span><span class="o">.</span><span class="n">ranges_index</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">index</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">int_range_set</span><span class="o">.</span><span class="n">ranges_getitem</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="go">(0, 10)</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.util.IntRangeSet.ranges_len">
<tt class="descname">ranges_len</tt><a class="headerlink" href="#pysnptools.util.IntRangeSet.ranges_len" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of contiguous ranges in the IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ranges_len</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.remove">
<tt class="descname">remove</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.remove" title="Permalink to this definition">¶</a></dt>
<dd><p>See <tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet__isub__()</span></tt></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.sum">
<tt class="descname">sum</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>The sum of the integer elements in the IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:10,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">57</span>
</pre></div>
</div>
<p>Note: This is more efficient than <tt class="docutils literal"><span class="pre">sum(IntRangeSet('0:10,12'))</span></tt> because is computed
in time linear in the number of ranges, rather than integer elements.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.symmetric_difference">
<tt class="descname">symmetric_difference</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.symmetric_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new IntRangeSet set with elements in either the input IntRangeSet or the input range but not both.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.symmetric_difference(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:11&#39;</span><span class="p">)</span> <span class="o">^</span> <span class="s">&#39;3:9&#39;</span>
<span class="go">IntRangeSet(&#39;0:3,5,9:11&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.symmetric_difference_update">
<tt class="descname">symmetric_difference_update</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.symmetric_difference_update" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.util.IntRangeSet.__ixor__" title="pysnptools.util.IntRangeSet.__ixor__"><tt class="xref py py-meth docutils literal"><span class="pre">IntRangeSet.__ixor__()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.union">
<tt class="descname">union</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the union of a IntRangeSet with zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.union(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="mi">5</span>
<span class="go">IntRangeSet(&#39;0:10&#39;)</span>
</pre></div>
</div>
<p>The &#8216;union&#8217; method also support unioning multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;100:200&#39;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0:10,100:200&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.IntRangeSet.update">
<tt class="descname">update</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.IntRangeSet.update" title="Permalink to this definition">¶</a></dt>
<dd><p>Union zero or more ranges inputs into the current IntRangeSet.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.add(b)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.update(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">|=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:10&#39;)</span>
</pre></div>
</div>
<p>The &#8216;add&#8217; and &#8216;update&#8217; methods also support unioning multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0:5,6:10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;5&#39;</span><span class="p">,</span><span class="s">&#39;100:200&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0:10,100:200&#39;)</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.util.pheno">
<span id="util-pheno"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">util.pheno</span></tt><a class="headerlink" href="#module-pysnptools.util.pheno" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pysnptools.util.pheno.loadOnePhen">
<tt class="descclassname">pysnptools.util.pheno.</tt><tt class="descname">loadOnePhen</tt><big>(</big><em>filename</em>, <em>i_pheno=0</em>, <em>missing='-9'</em>, <em>vectorize=False</em><big>)</big><a class="headerlink" href="#pysnptools.util.pheno.loadOnePhen" title="Permalink to this definition">¶</a></dt>
<dd><p>Load one column of a phenotype file. Remove any rows with missing data</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; name of the file</li>
<li><strong>i_pheno</strong> (<em>int</em>) &#8211; column to return (default &#8216;0&#8217;, the first column)</li>
<li><strong>missing</strong> (<em>string</em>) &#8211; value to threat as missing</li>
<li><strong>vectorize</strong> (<em>bool</em>) &#8211; if true, return a 1-D vector rather than a 2-D array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">An output dictionary</p>
</td>
</tr>
</tbody>
</table>
<p>The output dictionary looks like:</p>
<ul class="simple">
<li>&#8216;header&#8217; : [1] array phenotype namesv (only if header line is specified in file),</li>
<li>&#8216;vals&#8217;   : [N*1] array of phenotype-data,</li>
<li>&#8216;iid&#8217;    : [N*2] array of family IDs and individual IDs</li>
</ul>
</dd></dl>

<dl class="function">
<dt id="pysnptools.util.pheno.loadPhen">
<tt class="descclassname">pysnptools.util.pheno.</tt><tt class="descname">loadPhen</tt><big>(</big><em>filename</em>, <em>missing='-9'</em>, <em>famid='FID'</em>, <em>sampid='ID'</em><big>)</big><a class="headerlink" href="#pysnptools.util.pheno.loadPhen" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a phenotype or covariate file. Covariates have the same file format.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>filename</strong> (<em>string</em>) &#8211; name of the file</li>
<li><strong>missing</strong> (<em>string</em>) &#8211; value to threat as missing</li>
<li><strong>vectorize</strong> (<em>bool</em>) &#8211; if true, return a 1-D vector rather than a 2-D array</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">An output dictionary</p>
</td>
</tr>
</tbody>
</table>
<p>The output dictionary looks like:</p>
<ul class="simple">
<li>&#8216;header&#8217; : [1] array phenotype names (only if header line is specified in file),</li>
<li>&#8216;vals&#8217;   : [N*1] array of phenotype-data,</li>
<li>&#8216;iid&#8217;    : [N*2] array of family IDs and individual IDs</li>
</ul>
</dd></dl>

</div>
</div>
<div class="section" id="module-pysnptools.standardizer">
<span id="standardizer-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">standardizer</span></tt> Module<a class="headerlink" href="#module-pysnptools.standardizer" title="Permalink to this headline">¶</a></h2>
<p>Define classes such as <a class="reference internal" href="#pysnptools.standardizer.Unit" title="pysnptools.standardizer.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> and <a class="reference internal" href="#pysnptools.standardizer.Beta" title="pysnptools.standardizer.Beta"><tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt></a> to be used by the <a class="reference internal" href="#pysnptools.snpreader.SnpData.standardize" title="pysnptools.snpreader.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> method.</p>
<div class="section" id="standardizer-unit">
<h3><tt class="xref py py-class docutils literal"><span class="pre">standardizer.Unit</span></tt><a class="headerlink" href="#standardizer-unit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.Unit">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">Unit</tt><a class="headerlink" href="#pysnptools.standardizer.Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize data so that, for each snp, the mean of the values is zero with standard deviation 1.
NaN values are then filled with zero, the mean (consequently, if there are NaN values, the final standard deviation will not be zero.</p>
<dl class="method">
<dt id="pysnptools.standardizer.Unit.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>block_size=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.Unit.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="standardizer-identity">
<h3><tt class="xref py py-class docutils literal"><span class="pre">standardizer.Identity</span></tt><a class="headerlink" href="#standardizer-identity" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.Identity">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">Identity</tt><a class="headerlink" href="#pysnptools.standardizer.Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Do nothing to the data</p>
<dl class="method">
<dt id="pysnptools.standardizer.Identity.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>block_size=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.Identity.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="standardizer-beta">
<h3><tt class="xref py py-class docutils literal"><span class="pre">standardizer.Beta</span></tt><a class="headerlink" href="#standardizer-beta" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.Beta">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">Beta</tt><big>(</big><em>a=1</em>, <em>b=25</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.Beta" title="Permalink to this definition">¶</a></dt>
<dd><p>Beta standardize the data</p>
<dl class="method">
<dt id="pysnptools.standardizer.Beta.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>block_size=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.Beta.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="standardizer-bysidcount">
<h3><tt class="xref py py-class docutils literal"><span class="pre">standardizer.BySidCount</span></tt><a class="headerlink" href="#standardizer-bysidcount" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.BySidCount">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">BySidCount</tt><big>(</big><em>sid_count=None</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.BySidCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize data by dividing every value by the number of SNPs</p>
<dl class="method">
<dt id="pysnptools.standardizer.BySidCount.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>block_size=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.BySidCount.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="standardizer-bysqrtsidcount">
<h3><tt class="xref py py-class docutils literal"><span class="pre">standardizer.BySqrtSidCount</span></tt><a class="headerlink" href="#standardizer-bysqrtsidcount" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.BySqrtSidCount">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">BySqrtSidCount</tt><big>(</big><em>sid_count=None</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.BySqrtSidCount" title="Permalink to this definition">¶</a></dt>
<dd><p>Standardize data by dividing every value by the square root of the number of SNPs</p>
<dl class="method">
<dt id="pysnptools.standardizer.BySqrtSidCount.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>block_size=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.BySqrtSidCount.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="standardizer-diagkton-py">
<h3><tt class="xref py py-class docutils literal"><span class="pre">standardizer.DiagKtoN.py</span></tt><a class="headerlink" href="#standardizer-diagkton-py" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.DiagKtoN">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">DiagKtoN</tt><big>(</big><em>N</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.DiagKtoN" title="Permalink to this definition">¶</a></dt>
<dd><p>diag(K)=N standardization of the data</p>
<dl class="method">
<dt id="pysnptools.standardizer.DiagKtoN.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>block_size=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.DiagKtoN.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pysnptools.pstreader">
<span id="pstreader-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">pstreader</span></tt> Module<a class="headerlink" href="#module-pysnptools.pstreader" title="Permalink to this headline">¶</a></h2>
<p>Tools for reading PstReader files</p>
<div class="section" id="pstreader-pstreader">
<h3><tt class="xref py py-class docutils literal"><span class="pre">pstreader.PstReader</span></tt><a class="headerlink" href="#pstreader-pstreader" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.pstreader.PstReader">
<em class="property">class </em><tt class="descclassname">pysnptools.pstreader.</tt><tt class="descname">PstReader</tt><a class="headerlink" href="#pysnptools.pstreader.PstReader" title="Permalink to this definition">¶</a></dt>
<dd><p>The (abstract) base class for you to specify data and later read it.</p>
<p>A PstReader is one of three things:</p>
<p>#!!!cmk add in-memory examples
* A <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> class that holds data in memory, typically after a read:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#reads the values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The val property is an ndarray of values</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data1</span> <span class="c"># prints the specification of the in-memory information</span>
<span class="go">PstData(PstNpz(&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span><span class="o">.</span><span class="n">row_count</span> <span class="c">#prints the number of rows in this in-memory data</span>
<span class="go">300</span>
</pre></div>
</div>
<ul>
<li><p class="first">A class such as <a class="reference internal" href="#pysnptools.pstreader.PstNpz" title="pysnptools.pstreader.PstNpz"><tt class="xref py py-class docutils literal"><span class="pre">PstNpz</span></tt></a> for you to specify data in file. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span> <span class="c"># prints specification for reading from file</span>
<span class="go">PstNpz(&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span><span class="o">.</span><span class="n">col_count</span> <span class="c"># prints the number of columns (but doesn&#39;t read any column values)</span>
<span class="go">1015</span>
</pre></div>
</div>
</li>
<li><p class="first">A subset of any PstReader, specified with &#8220;[ <em>row_index</em> , <em>col_index</em> ]&#8221;, to read just some values.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># specification for a subset of the data on disk. No values are read yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">col_count</span> <span class="c"># prints the number of columns in this subset (but still doesn&#39;t read any values)</span>
<span class="go">508</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c">#prints a specification of &#39;subset_on_disk&#39;</span>
<span class="go">PstNpz(&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;)[[3,4],::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># efficiently reads the specified subset of values from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data_subset</span> <span class="c"># prints the specification of the in-memory information</span>
<span class="go">PstData(PstNpz(&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;)[[3,4],::2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">data_subset</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">data_subset</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c"># The dimensions of the ndarray of values</span>
<span class="go">(2, 508)</span>
</pre></div>
</div>
</li>
</ul>
<p>Methods &amp; Properties:</p>
<blockquote>
<div><p>Every PstReader, such as <a class="reference internal" href="#pysnptools.pstreader.PstNpz" title="pysnptools.pstreader.PstNpz"><tt class="xref py py-class docutils literal"><span class="pre">PstNpz</span></tt></a> and <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>, has these properties: <a class="reference internal" href="#pysnptools.pstreader.PstReader.row" title="pysnptools.pstreader.PstReader.row"><tt class="xref py py-attr docutils literal"><span class="pre">row</span></tt></a>, <a class="reference internal" href="#pysnptools.pstreader.PstReader.row_count" title="pysnptools.pstreader.PstReader.row_count"><tt class="xref py py-attr docutils literal"><span class="pre">row_count</span></tt></a>, <a class="reference internal" href="#pysnptools.pstreader.PstReader.col" title="pysnptools.pstreader.PstReader.col"><tt class="xref py py-attr docutils literal"><span class="pre">col</span></tt></a>, <a class="reference internal" href="#pysnptools.pstreader.PstReader.col_count" title="pysnptools.pstreader.PstReader.col_count"><tt class="xref py py-attr docutils literal"><span class="pre">col_count</span></tt></a>,
<a class="reference internal" href="#pysnptools.pstreader.PstReader.row_property" title="pysnptools.pstreader.PstReader.row_property"><tt class="xref py py-attr docutils literal"><span class="pre">row_property</span></tt></a>, <a class="reference internal" href="#pysnptools.pstreader.PstReader.col_property" title="pysnptools.pstreader.PstReader.col_property"><tt class="xref py py-attr docutils literal"><span class="pre">col_property</span></tt></a> and these methods: <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a>, <a class="reference internal" href="#pysnptools.pstreader.PstReader.row_to_index" title="pysnptools.pstreader.PstReader.row_to_index"><tt class="xref py py-meth docutils literal"><span class="pre">row_to_index()</span></tt></a>, <a class="reference internal" href="#pysnptools.pstreader.PstReader.col_to_index" title="pysnptools.pstreader.PstReader.col_to_index"><tt class="xref py py-meth docutils literal"><span class="pre">col_to_index()</span></tt></a>. See below for details.</p>
<p><a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> is a PstReader so it supports the above properties and methods. In addition, it supports property :attr:<a href="#id3"><span class="problematic" id="id4">`</span></a>.PstData.val.
See below for details.</p>
</div></blockquote>
<p>rows and cols:</p>
<blockquote>
<div><p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three rows</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten columns</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</div></blockquote>
<p>When PstData is Read:</p>
<blockquote>
<div><p>PstData can be enormous so we generally avoid reading it to the degree practical. Specifically,</p>
<ul>
<li><p class="first">Constructing and printing a PstReader causes no file reading. For example, these commands read no data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span> <span class="c"># Print the PstNpz PstReader specification. No data is read.</span>
<span class="go">PstNpz(&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c"># print the subset PstReader. No data is read.</span>
<span class="go">PstNpz(&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;)[[3,4],::2]</span>
</pre></div>
</div>
</li>
<li><p class="first">Properties and methods related to the rows and columns (to the degree practical) read only row and col data from the disk,
not value data. Moreover, the row and col data is read from file only once. Consider these commands:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># without reading any values data from disk, read the row and cik data from disk, cache it, and then print the first ten cols.</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#use the cached col information to find the indexes of &#39;1_10&#39; and &#39;1_13&#39;. (No data is read from disk.)</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</li>
<li><p class="first">The only methods that read values from file are :meth:<a href="#id5"><span class="problematic" id="id6">`</span></a>read (to the degree practical). For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#read all the values from disk, creating a new PstData instance that keeps these values in memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the value for the row with index 0 and the col with index 2. (No data is read from disk.)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</li>
<li><p class="first">If you request the values for only a subset of the rows or columns, (to the degree practical) only that subset will be read from disk.
for example:
#!!!cmk check that these don&#8217;t appear in this file: iid, col, PstNpz, SNP</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># from disk, read the values for the rows with index 3 and 4 AND cols with even numbered indexes.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data_subset</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the value with subset row index 0 and col index 2 (corresponding to row index 3 and col index 4 in the full data). No data is read from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>When PstData is Re-Read and Copied:</p>
<blockquote>
<div><p>Every time you call a PstReader&#8217;s <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> method, the PstReader re-reads the value data and returns a new in-memory <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>
(with <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> property containing a new ndarray of the values).</p>
<p>Here is an example of what not to do, because it causes all the SNP value data to be read twice.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Not recommended because it inefficiently reads all the values twice.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># read all values into a new PstData, print a value</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># read all values (again) into a second new PstData, print a value</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Here are two efficient alternatives. First, if all values can all fit in memory, read them once into a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> and then
access that <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> multiple times.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all values into a new PstData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print a value from data1&#39;s in-memory ndarray</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print another value from data1&#39;s in-memory ndarray.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Second, if the value data is too large to fit in memory, use subsetting to read only the values of interest from disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define the subset of data and read only that subset from disk.</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define a second subset of data and read only that subset from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Because the in-memory <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> class is a kind of PstReader, you may read from it, too.
Doing so create a new <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> instance containing a copy of the SNP values in a new ndarray.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values from disk into a new PstData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data1</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">data1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the in-memory SNP values use the same memory as themselves? Yes</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data2</span> <span class="o">=</span> <span class="n">data1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># copy all the SNP values into a new ndarray in a new PstData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data2</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">data1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the two ndarrays of in-memory SNP values use the same memory?</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Avoiding Unwanted ndarray Allocations</p>
<blockquote>
<div><p>You may want a subset of SNPs values from an in-memory <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> and you may know that this subset and the original <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>
can safely share the memory of the ndarray of SNP values. For this case, the <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> has optional parameters called view_ok and order. If you override 
the defaults of &#8220;view_ok=False,order=&#8217;F&#8217;&#8221; with &#8220;view_ok=True,order=&#8217;A&#8217;, the <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> will, if practical, return a new 
<a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a ndarray shares memory with the original ndarray.
Use these parameters with care because any change to either ndarray (for example, via <tt class="xref py py-meth docutils literal"><span class="pre">PstData.standardize()</span></tt>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Construct a PstNpz PstReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all data from disk into a PstData with a new ndarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column01</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create PstData with the data from just the first two SNPs. Sharing memory is OK. The memory may be laid out in any order (that is col-major and row-major are both OK).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#print np.may_share_memory(data1.val, column01.val) # Do the two ndarray&#39;s share memory? They could (but currently they won&#39;t)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column201</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create PstData with the data from three SNPs, permuted. Sharing memory is OK.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">column201</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># Do the two ndarray&#39;s share memory? No, ndarray decided that this indexing was too complex for sharing.</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Creating Subsetting PstReaders with Indexing</p>
<blockquote>
<div><p>You often don&#8217;t want to read the SNP values for all rows and cols. You can use indexing to create a subsetting PstReader that
will read only the SNP values of interest.</p>
<p>PstReaders support the indexing formats supported by ndarray plus two generalizations. Here are examples of indexing with an array
of indexes, with slicing, and with an array of Booleans.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in PstNpz format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_reader_1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:]</span> <span class="c">#index with an array of indexes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_reader_1</span><span class="o">.</span><span class="n">row_count</span><span class="p">,</span> <span class="n">subset_reader_1</span><span class="o">.</span><span class="n">col_count</span>
<span class="go">2 1015</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">subset_reader_1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read just the two rows of interest from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_reader_2</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[:,:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c">#index with a slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_reader_2</span><span class="o">.</span><span class="n">row_count</span><span class="p">,</span> <span class="n">subset_reader_2</span><span class="o">.</span><span class="n">col_count</span>
<span class="go">300 507</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boolindexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;23_&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col</span><span class="p">]</span> <span class="c"># create a Boolean index of cols that start &#39;23_&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_reader_3</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[:,</span><span class="n">boolindexes</span><span class="p">]</span> <span class="c">#index with array of Booleans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_reader_3</span><span class="o">.</span><span class="n">row_count</span><span class="p">,</span> <span class="n">subset_reader_3</span><span class="o">.</span><span class="n">col_count</span>
<span class="go">300 24</span>
</pre></div>
</div>
<p>The first generalization over with ndarray offers is full indexing on both the row dimension and the col dimension, in other words,
full multidimensional indexing. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in PstNpz format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_reader_4</span><span class="o">=</span> <span class="n">on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c"># index on two dimensions at once</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_reader_4</span><span class="o">.</span><span class="n">row_count</span><span class="p">,</span> <span class="n">subset_reader_4</span><span class="o">.</span><span class="n">col_count</span>
<span class="go">2 507</span>
</pre></div>
</div>
<p>The second generalization is indexing on a single integer index.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in PstNpz format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_reader_5</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span> <span class="c">#index with single integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_reader_5</span><span class="o">.</span><span class="n">row_count</span><span class="p">,</span> <span class="n">subset_reader_5</span><span class="o">.</span><span class="n">col_count</span>
<span class="go">1 1015</span>
</pre></div>
</div>
<p>Indexing is also useful when you have SNP values in memory via a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> index and want to copy a subset of those values.
While you could instead index directly on the <cite>.PstData.val</cite> ndarray, by indexing on the <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> instance you
also get row and cid information.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in PstNpz format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data1</span><span class="o">.</span><span class="n">col</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 cols</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_subset</span> <span class="o">=</span> <span class="n">data1</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c"># create a copy or view with every other col</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data_subset</span><span class="o">.</span><span class="n">col</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 cols in the subset</span>
<span class="go">[&#39;1_12&#39; &#39;1_10&#39; &#39;1_28&#39; &#39;1_36&#39; &#39;1_4&#39; &#39;1_11&#39; &#39;1_32&#39; &#39;1_9&#39; &#39;1_17&#39; &#39;1_18&#39;]</span>
</pre></div>
</div>
<p>You can apply indexing on top of indexing to specify subsets of subsets of data to read. In this example, 
only the SNP values for every 16th col is actually read from the disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># These are just PstReaders, nothing is read from disk yet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in PstNpz format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_reader</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half the cols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quarter_reader</span> <span class="o">=</span> <span class="n">half_reader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half the cols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sixteenth_reader</span> <span class="o">=</span> <span class="n">quarter_reader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">][:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half of half of half the cols</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sixteenth_reader</span> <span class="c">#Print the specification of this reader</span>
<span class="go">PstNpz(&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;)[:,::2][:,::2][:,::2][:,::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now we read from disk. Only values for one col in every 16 will be read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data_sixteenth</span> <span class="o">=</span> <span class="n">sixteenth_reader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">data_sixteenth</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">2.0</span>
</pre></div>
</div>
</div></blockquote>
<p>The <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> Method</p>
<blockquote>
<div>By default the <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> returns a ndarray of scipy.float64 laid out in memory in F-contiguous order (row-index varies the fastest). You may, instead,
ask for scipy.float32 or for C-contiguous order or any order. See <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> for details.</div></blockquote>
<dl class="attribute">
<dt id="pysnptools.pstreader.PstReader.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.pstreader.PstReader.col" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the cols. Each col is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.pstreader.PstReader.col_count" title="pysnptools.pstreader.PstReader.col_count"><tt class="xref py py-attr docutils literal"><span class="pre">col_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten cols</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstReader.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstReader.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstReader.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstReader.col_property" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each col. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.pstreader.PstReader.col_count" title="pysnptools.pstreader.PstReader.col_count"><tt class="xref py py-attr docutils literal"><span class="pre">col_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_property</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three cols:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstReader.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstReader.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstReader.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> (with <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (row-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (col-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <tt class="xref py py-meth docutils literal"><span class="pre">PstData.standardize()</span></tt>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.pstreader.PstReader.read" title="pysnptools.pstreader.PstReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the rows or cols, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a PstData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The PstData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_data</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other col</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_data</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_data</span> <span class="o">=</span> <span class="n">subset_data</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten rows. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_data.val, subsub_data.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstReader.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.pstreader.PstReader.row" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the rows. Each row is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.pstreader.PstReader.row_count" title="pysnptools.pstreader.PstReader.row_count"><tt class="xref py py-attr docutils literal"><span class="pre">row_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three rows</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstReader.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstReader.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstReader.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstReader.row_property" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each col. Each element is a ndarray of three scipy.numbers&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.pstreader.PstReader.col_count" title="pysnptools.pstreader.PstReader.col_count"><tt class="xref py py-attr docutils literal"><span class="pre">col_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print the shape of the information for the first three rows. It&#39;s 3 x 0 because it there are three rows, but in this example there is 0 per row information.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_property</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_property</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">3 0</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstReader.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstReader.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pstreader-pstdata">
<h3><tt class="xref py py-class docutils literal"><span class="pre">pstreader.PstData</span></tt><a class="headerlink" href="#pstreader-pstdata" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.pstreader.PstData">
<em class="property">class </em><tt class="descclassname">pysnptools.pstreader.</tt><tt class="descname">PstData</tt><big>(</big><em>row</em>, <em>col</em>, <em>val</em>, <em>row_property=None</em>, <em>col_property=None</em>, <em>parent_string=''</em>, <em>copyinputs_function=None</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstData" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class hold SNP values in-memory along with related iid and sid information.
It is created by calling the <a class="reference internal" href="#pysnptools.snpreader.SnpReader.read" title="pysnptools.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">SnpReader.read()</span></tt></a> method on another <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a>, for example, <a class="reference internal" href="#pysnptools.snpreader.Bed" title="pysnptools.snpreader.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader" title="pysnptools.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> for details and examples.</p>
<dl class="attribute">
<dt id="pysnptools.pstreader.PstData.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.pstreader.PstData.col" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.sid" title="pysnptools.snpreader.SnpReader.sid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.sid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstData.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstData.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstData.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstData.col_property" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.pos" title="pysnptools.snpreader.SnpReader.pos"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.pos</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstData.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstData.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstData.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstData.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> (with <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (row-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (col-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <tt class="xref py py-meth docutils literal"><span class="pre">PstData.standardize()</span></tt>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.pstreader.PstData.read" title="pysnptools.pstreader.PstData.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the rows or cols, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a PstData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The PstData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_data</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other col</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_data</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_data</span> <span class="o">=</span> <span class="n">subset_data</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten rows. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_data.val, subsub_data.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstData.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.pstreader.PstData.row" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.iid" title="pysnptools.snpreader.SnpReader.iid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.iid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstData.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstData.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstData.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstData.row_property" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.SnpReader.pos" title="pysnptools.snpreader.SnpReader.pos"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.pos</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstData.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstData.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstData.val">
<tt class="descname">val</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.pstreader.PstData.val" title="Permalink to this definition">¶</a></dt>
<dd><p>The in-memory data. A numpy.ndarray with dimensions <a class="reference internal" href="#pysnptools.pstreader.PstData.row_count" title="pysnptools.pstreader.PstData.row_count"><tt class="xref py py-attr docutils literal"><span class="pre">row_count</span></tt></a> x <a class="reference internal" href="#pysnptools.pstreader.PstData.col_count" title="pysnptools.pstreader.PstData.col_count"><tt class="xref py py-attr docutils literal"><span class="pre">col_count</span></tt></a>.</p>
<p>See <a class="reference internal" href="#pysnptools.pstreader.PstReader" title="pysnptools.pstreader.PstReader"><tt class="xref py py-class docutils literal"><span class="pre">PstReader</span></tt></a> for details and examples.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="pstreader-psthdf5">
<h3><tt class="xref py py-class docutils literal"><span class="pre">pstreader.PstHdf5</span></tt><a class="headerlink" href="#pstreader-psthdf5" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.pstreader.PstHdf5">
<em class="property">class </em><tt class="descclassname">pysnptools.pstreader.</tt><tt class="descname">PstHdf5</tt><big>(</big><em>filename</em>, <em>block_size=5000</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5" title="Permalink to this definition">¶</a></dt>
<dd><dl class="attribute">
<dt id="pysnptools.pstreader.PstHdf5.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstHdf5.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstHdf5.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstHdf5.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstHdf5.create_block">
<tt class="descname">create_block</tt><big>(</big><em>block_size</em>, <em>order</em>, <em>dtype</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.create_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstHdf5.h5">
<tt class="descname">h5</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.h5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstHdf5.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> (with <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (row-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (col-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <tt class="xref py py-meth docutils literal"><span class="pre">PstData.standardize()</span></tt>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.pstreader.PstHdf5.read" title="pysnptools.pstreader.PstHdf5.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the rows or cols, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a PstData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The PstData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_data</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other col</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_data</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_data</span> <span class="o">=</span> <span class="n">subset_data</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten rows. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_data.val, subsub_data.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstHdf5.read_direct">
<tt class="descname">read_direct</tt><big>(</big><em>val</em>, <em>selection=(slice(None</em>, <em>None</em>, <em>None)</em>, <em>slice(None</em>, <em>None</em>, <em>None))</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.read_direct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstHdf5.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstHdf5.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstHdf5.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstHdf5.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstHdf5.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.pstreader.PstHdf5.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>pstdata</em>, <em>dtype='f8'</em>, <em>col_major=True</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstHdf5.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="pstreader-pstnpz">
<h3><tt class="xref py py-class docutils literal"><span class="pre">pstreader.PstNpz</span></tt><a class="headerlink" href="#pstreader-pstnpz" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.pstreader.PstNpz">
<em class="property">class </em><tt class="descclassname">pysnptools.pstreader.</tt><tt class="descname">PstNpz</tt><big>(</big><em>pstnpz_filename</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstNpz" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that reads into memory from PstNpz files.</p>
<dl class="attribute">
<dt id="pysnptools.pstreader.PstNpz.col">
<tt class="descname">col</tt><a class="headerlink" href="#pysnptools.pstreader.PstNpz.col" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstNpz.col_count">
<tt class="descname">col_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstNpz.col_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of cols</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstNpz.col_property">
<tt class="descname">col_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstNpz.col_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstNpz.col_to_index">
<tt class="descname">col_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstNpz.col_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of cols and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of cols</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">col_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two cols.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstNpz.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstNpz.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> (with <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (row-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (col-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.pstreader.PstData.val" title="pysnptools.pstreader.PstData.val"><tt class="xref py py-attr docutils literal"><span class="pre">PstData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <tt class="xref py py-meth docutils literal"><span class="pre">PstData.standardize()</span></tt>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.pstreader.PstNpz.read" title="pysnptools.pstreader.PstNpz.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.pstreader.PstData" title="pysnptools.pstreader.PstData"><tt class="xref py py-class docutils literal"><span class="pre">PstData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the rows or cols, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data1</span> <span class="o">=</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a PstData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">data1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The PstData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_data</span> <span class="o">=</span> <span class="n">on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other col</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_data</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_data</span> <span class="o">=</span> <span class="n">subset_data</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten rows. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_data.val, subsub_data.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstNpz.row">
<tt class="descname">row</tt><a class="headerlink" href="#pysnptools.pstreader.PstNpz.row" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstNpz.row_count">
<tt class="descname">row_count</tt><a class="headerlink" href="#pysnptools.pstreader.PstNpz.row_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of rows</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.pstreader.PstNpz.row_property">
<tt class="descname">row_property</tt><a class="headerlink" href="#pysnptools.pstreader.PstNpz.row_property" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstNpz.row_to_index">
<tt class="descname">row_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstNpz.row_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of rows and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of rows</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only row and col data from the disk, not SNP value data. Moreover, the row and col data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.pstreader</span> <span class="kn">import</span> <span class="n">PstNpz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">on_disk</span> <span class="o">=</span> <span class="n">PstNpz</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300.pst.npz&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">on_disk</span><span class="o">.</span><span class="n">row_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two rows.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.pstreader.PstNpz.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstNpz.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.pstreader.PstNpz.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>filename</em>, <em>pstdata</em><big>)</big><a class="headerlink" href="#pysnptools.pstreader.PstNpz.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="indices-and-tables">
<h2>Indices and Tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div></blockquote>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">pysnptools</span></tt> Documentation</a><ul>
<li><a class="reference internal" href="#module-pysnptools.snpreader"><tt class="docutils literal"><span class="pre">snpreader</span></tt> Module</a><ul>
<li><a class="reference internal" href="#snpreader-snpreader"><tt class="docutils literal"><span class="pre">snpreader.SnpReader</span></tt></a></li>
<li><a class="reference internal" href="#snpreader-bed"><tt class="docutils literal"><span class="pre">snpreader.Bed</span></tt></a></li>
<li><a class="reference internal" href="#snpreader-pheno"><tt class="docutils literal"><span class="pre">snpreader.Pheno</span></tt></a></li>
<li><a class="reference internal" href="#snpreader-snpdata"><tt class="docutils literal"><span class="pre">snpreader.SnpData</span></tt></a></li>
<li><a class="reference internal" href="#snpreader-ped"><tt class="docutils literal"><span class="pre">snpreader.Ped</span></tt></a></li>
<li><a class="reference internal" href="#snpreader-dat"><tt class="docutils literal"><span class="pre">snpreader.Dat</span></tt></a></li>
<li><a class="reference internal" href="#snpreader-snphdf5"><tt class="docutils literal"><span class="pre">snpreader.SnpHdf5</span></tt></a></li>
<li><a class="reference internal" href="#snpreader-snpnpz"><tt class="docutils literal"><span class="pre">snpreader.SnpNpz</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#kernelreader-module"><tt class="docutils literal"><span class="pre">kernelreader</span></tt> Module</a><ul>
<li><a class="reference internal" href="#kernelreader-kernelreader"><tt class="docutils literal"><span class="pre">kernelreader.KernelReader</span></tt></a></li>
<li><a class="reference internal" href="#kernelreader-kerneldata"><tt class="docutils literal"><span class="pre">kernelreader.KernelData</span></tt></a></li>
<li><a class="reference internal" href="#kernelreader-identity"><tt class="docutils literal"><span class="pre">kernelreader.Identity</span></tt></a></li>
<li><a class="reference internal" href="#kernelreader-kernelhdf5"><tt class="docutils literal"><span class="pre">kernelreader.KernelHdf5</span></tt></a></li>
<li><a class="reference internal" href="#kernelreader-kernelnpz"><tt class="docutils literal"><span class="pre">kernelreader.KernelNpz</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pysnptools.util"><tt class="docutils literal"><span class="pre">util</span></tt> Module</a><ul>
<li><a class="reference internal" href="#util-intrangeset"><tt class="docutils literal"><span class="pre">util.IntRangeSet</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.util.pheno"><tt class="docutils literal"><span class="pre">util.pheno</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pysnptools.standardizer"><tt class="docutils literal"><span class="pre">standardizer</span></tt> Module</a><ul>
<li><a class="reference internal" href="#standardizer-unit"><tt class="docutils literal"><span class="pre">standardizer.Unit</span></tt></a></li>
<li><a class="reference internal" href="#standardizer-identity"><tt class="docutils literal"><span class="pre">standardizer.Identity</span></tt></a></li>
<li><a class="reference internal" href="#standardizer-beta"><tt class="docutils literal"><span class="pre">standardizer.Beta</span></tt></a></li>
<li><a class="reference internal" href="#standardizer-bysidcount"><tt class="docutils literal"><span class="pre">standardizer.BySidCount</span></tt></a></li>
<li><a class="reference internal" href="#standardizer-bysqrtsidcount"><tt class="docutils literal"><span class="pre">standardizer.BySqrtSidCount</span></tt></a></li>
<li><a class="reference internal" href="#standardizer-diagkton-py"><tt class="docutils literal"><span class="pre">standardizer.DiagKtoN.py</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pysnptools.pstreader"><tt class="docutils literal"><span class="pre">pstreader</span></tt> Module</a><ul>
<li><a class="reference internal" href="#pstreader-pstreader"><tt class="docutils literal"><span class="pre">pstreader.PstReader</span></tt></a></li>
<li><a class="reference internal" href="#pstreader-pstdata"><tt class="docutils literal"><span class="pre">pstreader.PstData</span></tt></a></li>
<li><a class="reference internal" href="#pstreader-psthdf5"><tt class="docutils literal"><span class="pre">pstreader.PstHdf5</span></tt></a></li>
<li><a class="reference internal" href="#pstreader-pstnpz"><tt class="docutils literal"><span class="pre">pstreader.PstNpz</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#indices-and-tables">Indices and Tables</a></li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pysnptools 0.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Carl Kadie.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>