<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pysnptools Documentation &mdash; pysnptools 0.0.1 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pysnptools 0.0.1 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pysnptools 0.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-pysnptools">
<span id="pysnptools-documentation"></span><h1><a class="reference internal" href="#module-pysnptools" title="pysnptools"><tt class="xref py py-mod docutils literal"><span class="pre">pysnptools</span></tt></a> Documentation<a class="headerlink" href="#module-pysnptools" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-pysnptools.snpreader">
<span id="snpreader-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">snpreader</span></tt> Module<a class="headerlink" href="#module-pysnptools.snpreader" title="Permalink to this headline">¶</a></h2>
<p>Tools for reading SNP files</p>
<div class="section" id="module-pysnptools.snpreader.snpreader">
<span id="snpreader-snpreader"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">snpreader.snpreader</span></tt><a class="headerlink" href="#module-pysnptools.snpreader.snpreader" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.snpreader.SnpReader">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.snpreader.</tt><tt class="descname">SnpReader</tt><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader" title="Permalink to this definition">¶</a></dt>
<dd><p>The (abstract) base class for you to specify SNP data and later read it.</p>
<p>A SnpReader is one of three things:</p>
<ul>
<li><p class="first">A class such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a> for you to specify data in file. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span> <span class="c"># prints specification for reading from file</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_count</span> <span class="c"># prints the number of SNPS (but doesn&#39;t read any SNP values)</span>
<span class="go">1015</span>
</pre></div>
</div>
</li>
<li><p class="first">A <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> class that holds SNP data in memory, typically after a read:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#reads the SNP values</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The val property is an ndarray of SNP values</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># prints the specification of the in-memory SNP information</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">iid_count</span> <span class="c">#prints the number of iids (number of individuals) in this in-memory data</span>
<span class="go">300</span>
</pre></div>
</div>
</li>
<li><p class="first">A subset of any SnpReader, specified with &#8220;[ <em>iid_index</em> , <em>sid_index</em> ]&#8221;, to read only some SNP values.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># specification for a subset of the data on disk. No SNP values are read yet.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">sid_count</span> <span class="c"># prints the number of sids in this subset (but still doesn&#39;t read any SNP values)</span>
<span class="go">508</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c">#prints a specification of &#39;subset_on_disk&#39;</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># efficiently reads the specified subset of values from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span> <span class="c"># prints the specification of the in-memory SNP information</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">int</span><span class="p">(</span><span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c"># The dimensions of the ndarray of SNP values</span>
<span class="go">(2, 508)</span>
</pre></div>
</div>
</li>
</ul>
<p>Methods &amp; Properties:</p>
<blockquote>
<div><p>Every SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a> and <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, has these properties: <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.iid" title="pysnptools.snpreader.snpreader.SnpReader.iid"><tt class="xref py py-attr docutils literal"><span class="pre">iid</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.sid" title="pysnptools.snpreader.snpreader.SnpReader.sid"><tt class="xref py py-attr docutils literal"><span class="pre">sid</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.sid_count" title="pysnptools.snpreader.snpreader.SnpReader.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>,
<a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.pos" title="pysnptools.snpreader.snpreader.SnpReader.pos"><tt class="xref py py-attr docutils literal"><span class="pre">pos</span></tt></a> and these methods: <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.iid_to_index" title="pysnptools.snpreader.snpreader.SnpReader.iid_to_index"><tt class="xref py py-meth docutils literal"><span class="pre">iid_to_index()</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.sid_to_index" title="pysnptools.snpreader.snpreader.SnpReader.sid_to_index"><tt class="xref py py-meth docutils literal"><span class="pre">sid_to_index()</span></tt></a>, <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="pysnptools.snpreader.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt></a>. See below for details.</p>
<p><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> is a SnpReader so it supports the above properties and method. In addition, it supports property <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> and method <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>.
See below for details.</p>
</div></blockquote>
<p>iids and sids:</p>
<blockquote>
<div><p>Individual are identified with an iid, which is a ndarray of two strings: a family ID and a case ID. SNP locations 
are identified with sid string. For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</div></blockquote>
<p>When Data is Read:</p>
<blockquote>
<div><p>SNP data can be enormous so generally avoid reading it to the degree practical. Specifically,</p>
<ul>
<li><p class="first">Constructing and printing a SnpReader causes no file reading. For example, these commands read no data:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span> <span class="c"># Print the Bed SnpReader specification. No data is read.</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_on_disk</span> <span class="c"># print the subset SnpReader. No data is read.</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[[3,4],::2]</span>
</pre></div>
</div>
</li>
<li><p class="first">Properties and methods related to the iids and sids (to the degree practical) read only iid and sid data from the disk,
not SNP value data. Moreover, the iid and sid data is read from file only once. Consider these commands:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># without reading any SNP values data from disk, read the sid and iid data from disk, cache it, and then print the first ten sids.</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#use the cached sid information to find the indexes of &#39;1_10&#39; and &#39;1_13&#39;. (No data is read from disk.)</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</li>
<li><p class="first">The only methods that read SNP values from file are <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> and <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="pysnptools.snpreader.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt></a> (to the degree practical). For example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c">#read all the SNP values from disk, creating a new SnpData instance that keeps these values in memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the SNP value for the iid with index 0 and the sid with index 2. (No data is read from disk.)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</li>
<li><p class="first">If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.
for example:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">subset_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># Construct a subsetting SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">subset_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># from disk, read the SNP values for the iids with index 3 and 4 AND sids with even numbered indexes.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print the SNP value with subset iid index 0 and sid index 2 (corresponding to iid index 3 and sid index 4 in the full data). No data is read from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
</li>
</ul>
</div></blockquote>
<p>When Data is Re-Read and Copied:</p>
<blockquote>
<div><p>Every time you call a SnpReader&#8217;s <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> method, the SnpReader re-reads the SNP value data and returns a new in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>
(with <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values). Likewise, when you call the <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="pysnptools.snpreader.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt></a> method, the SnpReader re-reads
the data and returns a new kernel ndarray.</p>
<p>Here is an example of what not to do, because it causes all the SNP value data to be read twice.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Not recommended because it inefficiently reads all the SNP values twice.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># read all values into a new SnpData, print a SNP value</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># read all values (again) into a second new SnpData, print a SNP value</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Here are two efficient alternatives. First, if all SNP values can all fit in memory, read them once into a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> and then
access that <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> multiple times.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all values into a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="c"># print a SNP value from snpdata1&#39;s in-memory ndarray</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print another SNP value from snpdata1&#39;s in-memory ndarray.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Second, if the SNP value data is too large to fit in memory, use subsetting to read only the SNP values of interest from disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define the subset of data and read only that subset from disk.</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c">#Define a second subset of data and read only that subset from disk.</span>
<span class="go">2.0</span>
</pre></div>
</div>
<p>Because the in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> class is a kind of SnpReader, you may read from it, too.
Doing so create a new <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> instance containing a copy of the SNP values in a new ndarray.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values from disk into a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the in-memory SNP values use the same memory as themselves? Yes</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># copy all the SNP values into a new ndarray in a new SnpData</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span> <span class="ow">is</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span> <span class="c"># Do the two ndarrays of in-memory SNP values use the same memory?</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Avoiding Unwanted ndarray Allocations</p>
<blockquote>
<div><p>You may want a subset of SNPs values from an in-memory <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> and you may know that this subset and the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>
can safely share the memory of the ndarray of SNP values. For this case, the <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> has optional parameters called view_ok and order. If you override 
the defaults of &#8220;view_ok=False,order=&#8217;F&#8217;&#8221; with &#8220;view_ok=True,order=&#8217;A&#8217;, the <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> will, if practical, return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original ndarray.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Construct a Bed SnpReader. No data is read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all data from disk into a SnpData with a new ndarray</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column01</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create SnpData with the data from just the first two SNPs. Sharing memory is OK. The memory may be laid out in any order (that is sid-major and iid-major are both OK).</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#print np.may_share_memory(snpdata1.val, column01.val) # Do the two ndarray&#39;s share memory? They could (but currently they won&#39;t)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">column201</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c">#create SnpData with the data from three SNPs, permuted. Sharing memory is OK.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">np</span><span class="o">.</span><span class="n">may_share_memory</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">,</span> <span class="n">column201</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># Do the two ndarray&#39;s share memory? No, ndarray decided that this indexing was too complex for sharing.</span>
<span class="go">False</span>
</pre></div>
</div>
</div></blockquote>
<p>Creating Subsetting SnpReaders with Indexing</p>
<blockquote>
<div><p>You often don&#8217;t want to read the SNP values for all iids and sids. You can use indexing to create a subsetting SnpReader that
will read only the SNP values of interest.</p>
<p>SnpReaders support the indexing formats supported by ndarray plus two generalizations. Here are examples of indexing with an array
of indexes, with slicing, and with an array of Booleans.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:]</span> <span class="c">#index with an array of indexes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">2 1015</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">subset_snpreader_1</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read just the two rows of interest from the disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c">#index with a slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_2</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_2</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">300 507</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boolindexes</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">&#39;23_&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">]</span> <span class="c"># create a Boolean index of sids that start &#39;23_&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_3</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,</span><span class="n">boolindexes</span><span class="p">]</span> <span class="c">#index with array of Booleans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_3</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_3</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">300 24</span>
</pre></div>
</div>
<p>The first generalization over with ndarray offers is full indexing on both the iid dimension and the sid dimension, in other words,
full multidimensional indexing. For example,</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_4</span><span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[[</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],:</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="c"># index on two dimensions at once</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_4</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_4</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">2 507</span>
</pre></div>
</div>
<p>The second generalization is indexing on a single integer index.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpreader_5</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[</span><span class="mi">5</span><span class="p">,:]</span> <span class="c">#index with single integer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpreader_5</span><span class="o">.</span><span class="n">iid_count</span><span class="p">,</span> <span class="n">subset_snpreader_5</span><span class="o">.</span><span class="n">sid_count</span>
<span class="go">1 1015</span>
</pre></div>
</div>
<p>Indexing is also useful when you have SNP values in memory via a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> index and want to copy a subset of those values.
While you could instead index directly on the <cite>.SnpData.val</cite> ndarray, by indexing on the <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> instance you
also get iid and cid information.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_subset</span> <span class="o">=</span> <span class="n">snpdata1</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">)</span> <span class="c"># create a copy or view with every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_subset</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first 10 sids in the subset</span>
<span class="go">[&#39;1_12&#39; &#39;1_10&#39; &#39;1_28&#39; &#39;1_36&#39; &#39;1_4&#39; &#39;1_11&#39; &#39;1_32&#39; &#39;1_9&#39; &#39;1_17&#39; &#39;1_18&#39;]</span>
</pre></div>
</div>
<p>You can apply indexing on top of indexing to specify subsets of subsets of data to read. In this example, 
only the SNP values for every 16th sid is actually read from the disk.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="c"># These are just SnpReaders, nothing is read from disk yet</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">half_snpreader</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">quarter_snpreader</span> <span class="o">=</span> <span class="n">half_snpreader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sixteenth_snpreader</span> <span class="o">=</span> <span class="n">quarter_snpreader</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">][:,::</span><span class="mi">2</span><span class="p">]</span> <span class="c"># a reader for half of half of half of half the sids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">sixteenth_snpreader</span> <span class="c">#Print the specification of this reader</span>
<span class="go">Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;)[:,::2][:,::2][:,::2][:,::2]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Now we read from disk. Only values for one sid in every 16 will be read.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata_sixteenth</span> <span class="o">=</span> <span class="n">sixteenth_snpreader</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata_sixteenth</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="go">2.0</span>
</pre></div>
</div>
</div></blockquote>
<p>The <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> Method</p>
<blockquote>
<div>By default the <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> returns a ndarray of scipy.float64 laid out in memory in F-contiguous order (iid-index varies the fastest). You may, instead,
ask for scipy.float32 or for C-contiguous order or any order. See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> for details.</div></blockquote>
<dl class="docutils">
<dt>The <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> Method</dt>
<dd><p class="first">The <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> method, available only on <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, does in-place standardization of the in-memory
SNP data. By default, it applies &#8216;Unit&#8217; standardization, that is: the values for each SNP will have mean zero and standard deviation 1.0.
Note that, for efficiently, this method works in-place, actually changing values in the ndarray. Although it works in place, for convenience
it also returns itself. See <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a> for options and details.</p>
<div class="last highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># Prints the specification for this SnpData</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># standardize changes the values in snpdata1.val and changes the specification.</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;),Unit())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># Read and standardize in one expression with only one ndarray allocated.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
</pre></div>
</div>
</dd>
</dl>
<p>The <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="pysnptools.snpreader.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt></a> Method</p>
<blockquote>
<div>The <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="pysnptools.snpreader.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt></a> method, available on any SnpReader, returns a ndarray of size iid_count x iid_count. The returned array has the value
of the (optionally standardized) SNP values transposed and then multiplied with themselves. When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>,
the method can save memory by reading (and standardizing) the data in blocks. See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="pysnptools.snpreader.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">kernel()</span></tt></a> for details.</div></blockquote>
<dl class="attribute">
<dt id="pysnptools.snpreader.snpreader.SnpReader.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids. Each iid is a ndarray of two strings (a family ID and a case ID) that identifies an individual.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a>) of ndarray (length 2) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print the first three iids</span>
<span class="go">[[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpreader.SnpReader.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpreader.SnpReader.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpreader.SnpReader.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any <tt class="xref py py-class docutils literal"><span class="pre">standardizer</span></tt> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.identity.Identity" title="pysnptools.standardizer.identity.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.unit.Unit" title="pysnptools.standardizer.unit.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.iid_count" title="pysnptools.snpreader.snpreader.SnpReader.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer.unit</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpreader.SnpReader.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid. Each element is a ndarray of three scipy.float64&#8217;s (chromosome, genetic distance, basepair distance).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.sid_count" title="pysnptools.snpreader.snpreader.SnpReader.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of ndarray (length 3) of scipy.float64</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">pos</span><span class="p">[:</span><span class="mi">3</span><span class="p">]</span> <span class="c"># print position information for the first three sids:</span>
<span class="go">[[ 1.          0.00800801  0.        ]</span>
<span class="go"> [ 1.          0.023023    1.        ]</span>
<span class="go"> [ 1.          0.0700701   4.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpreader.SnpReader.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpreader.SnpReader.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids. Each sid is a string that identifies a SNP.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">ndarray (length <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.sid_count" title="pysnptools.snpreader.snpreader.SnpReader.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>) of strings</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid</span><span class="p">[:</span><span class="mi">10</span><span class="p">]</span> <span class="c"># print the first ten sids</span>
<span class="go">[&#39;1_12&#39; &#39;1_34&#39; &#39;1_10&#39; &#39;1_35&#39; &#39;1_28&#39; &#39;1_25&#39; &#39;1_36&#39; &#39;1_39&#39; &#39;1_4&#39; &#39;1_13&#39;]</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpreader.SnpReader.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpreader.SnpReader.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpreader.SnpReader.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.snpreader.bed">
<span id="snpreader-bed"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">snpreader.bed</span></tt><a class="headerlink" href="#module-pysnptools.snpreader.bed" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.bed.Bed">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.bed.</tt><tt class="descname">Bed</tt><big>(</big><em>basefilename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.bed.Bed" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that does random-access reads of a Bed/Bim/Fam files from disk.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> for details and examples.</p>
<dl class="docutils">
<dt>Constructor:</dt>
<dd><dl class="first last docutils">
<dt>basefilename <span class="classifier-delimiter">:</span> <span class="classifier">string of the basename of [basename].bed, [basename].bim,</span></dt>
<dd>and [basename].fam</dd>
</dl>
</dd>
</dl>
<dl class="attribute">
<dt id="pysnptools.snpreader.bed.Bed.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>list of iids</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.bed.Bed.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.bed.Bed.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.bed.Bed.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any <tt class="xref py py-class docutils literal"><span class="pre">standardizer</span></tt> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.identity.Identity" title="pysnptools.standardizer.identity.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.unit.Unit" title="pysnptools.standardizer.unit.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.bed.Bed.iid_count" title="pysnptools.snpreader.bed.Bed.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.bed.Bed.iid_count" title="pysnptools.snpreader.bed.Bed.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer.unit</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.bed.Bed.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>list of position information</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.bed.Bed.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.bed.Bed.read" title="pysnptools.snpreader.bed.Bed.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.bed.Bed.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>list of sids</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.bed.Bed.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.bed.Bed.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.bed.Bed.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.snpreader.snpdata">
<span id="snpreader-snpdata"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">snpreader.snpdata</span></tt><a class="headerlink" href="#module-pysnptools.snpreader.snpdata" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.snpdata.SnpData">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.snpdata.</tt><tt class="descname">SnpData</tt><big>(</big><em>iid</em>, <em>sid</em>, <em>pos</em>, <em>val</em>, <em>parent_string=''</em>, <em>copyinputs_function=None</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class hold SNP values in-memory along with related iid and sid information.
It is created by calling the <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.read" title="pysnptools.snpreader.snpreader.SnpReader.read"><tt class="xref py py-meth docutils literal"><span class="pre">SnpReader.read()</span></tt></a> method on another <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a>, for example, <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> for details and examples.</p>
<dl class="attribute">
<dt id="pysnptools.snpreader.snpdata.SnpData.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.iid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the iids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.iid" title="pysnptools.snpreader.snpreader.SnpReader.iid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.iid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpdata.SnpData.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpdata.SnpData.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpdata.SnpData.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>blocksize=10000</em>, <em>allowlowrank=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.kernel" title="pysnptools.snpreader.snpreader.SnpReader.kernel"><tt class="xref py py-meth docutils literal"><span class="pre">SnpReader.kernel()</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpdata.SnpData.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.pos" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the position information for each sid.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.pos" title="pysnptools.snpreader.snpreader.SnpReader.pos"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.pos</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpdata.SnpData.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>, will return a new 
<a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a ndarray shares memory with the original <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.read" title="pysnptools.snpreader.snpdata.SnpData.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpdata.SnpData.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.sid" title="Permalink to this definition">¶</a></dt>
<dd><p>A ndarray of the sids.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader.sid" title="pysnptools.snpreader.snpreader.SnpReader.sid"><tt class="xref py py-attr docutils literal"><span class="pre">SnpReader.sid</span></tt></a> for details and examples.</p>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpdata.SnpData.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpdata.SnpData.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.snpdata.SnpData.standardize">
<tt class="descname">standardize</tt><big>(</big><em>standardizer=Unit()</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="Permalink to this definition">¶</a></dt>
<dd><p>Does in-place standardization of the in-memory
SNP data. By default, it applies &#8216;Unit&#8217; standardization, that is: the values for each SNP will have mean zero and standard deviation 1.0.
Note that, for efficiently, this method works in-place, actually changing values in the ndarray. Although it works in place, for convenience
it also returns itself.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; optional &#8211; Specify standardization to be applied before the matrix multiply. 
Any <tt class="xref py py-class docutils literal"><span class="pre">Standardizer</span></tt> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.unit.Unit" title="pysnptools.standardizer.unit.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (default, makes values for each SNP have mean zero and
standard deviation 1.0), <a class="reference internal" href="#pysnptools.standardizer.beta.Beta" title="pysnptools.standardizer.beta.Beta"><tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt></a>, <a class="reference internal" href="#pysnptools.standardizer.bysidcount.BySidCount" title="pysnptools.standardizer.bysidcount.BySidCount"><tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt></a>, <a class="reference internal" href="#pysnptools.standardizer.bysqrtsidcount.BySqrtSidCount" title="pysnptools.standardizer.bysqrtsidcount.BySqrtSidCount"><tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt></a>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of None. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (standardizes in place, but for convenience, returns &#8216;self&#8217;)</p>
</td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify some data on disk in Bed format</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># read all SNP values into memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span> <span class="c"># Prints the specification for this SnpData</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># standardize changes the values in snpdata1.val and changes the specification.</span>
<span class="go">SnpData(Bed(&#39;../tests/datasets/all_chr.maf0.001.N300&#39;),Unit())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata2</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span><span class="o">.</span><span class="n">standardize</span><span class="p">()</span> <span class="c"># Read and standardize in one expression with only one ndarray allocated.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snpdata2</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">0.229415733871</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.snpdata.SnpData.val">
<tt class="descname">val</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.snpreader.snpdata.SnpData.val" title="Permalink to this definition">¶</a></dt>
<dd><p>The in-memory SNP data. A numpy.ndarray with dimensions <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.iid_count" title="pysnptools.snpreader.snpdata.SnpData.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.sid_count" title="pysnptools.snpreader.snpdata.SnpData.sid_count"><tt class="xref py py-attr docutils literal"><span class="pre">sid_count</span></tt></a>.</p>
<p>See <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> for details and examples.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.snpreader.ped">
<span id="snpreader-ped"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">snpreader.ped</span></tt><a class="headerlink" href="#module-pysnptools.snpreader.ped" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.ped.Ped">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.ped.</tt><tt class="descname">Ped</tt><big>(</big><em>basefilename</em>, <em>missing='0'</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.ped.Ped" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that does a Ped file. For examples of its use see its &#8216;read&#8217; method. #!!LATER update comments</p>
<dl class="attribute">
<dt id="pysnptools.snpreader.ped.Ped.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.iid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.ped.Ped.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.ped.Ped.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.ped.Ped.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any <tt class="xref py py-class docutils literal"><span class="pre">standardizer</span></tt> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.identity.Identity" title="pysnptools.standardizer.identity.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.unit.Unit" title="pysnptools.standardizer.unit.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.ped.Ped.iid_count" title="pysnptools.snpreader.ped.Ped.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.ped.Ped.iid_count" title="pysnptools.snpreader.ped.Ped.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer.unit</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.ped.Ped.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.ped.Ped.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.ped.Ped.read" title="pysnptools.snpreader.ped.Ped.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.ped.Ped.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.ped.Ped.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.sid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.ped.Ped.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.ped.Ped.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.ped.Ped.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>snpdata</em>, <em>basefilename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.ped.Ped.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.snpreader.dat">
<span id="snpreader-dat"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">snpreader.dat</span></tt><a class="headerlink" href="#module-pysnptools.snpreader.dat" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.dat.Dat">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.dat.</tt><tt class="descname">Dat</tt><big>(</big><em>dat_filename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that reads into memory from DAT/FAM/MAP files.</p>
<dl class="attribute">
<dt id="pysnptools.snpreader.dat.Dat.datfields">
<tt class="descname">datfields</tt><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.datfields" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.dat.Dat.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.iid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.dat.Dat.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.dat.Dat.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.dat.Dat.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any <tt class="xref py py-class docutils literal"><span class="pre">standardizer</span></tt> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.identity.Identity" title="pysnptools.standardizer.identity.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.unit.Unit" title="pysnptools.standardizer.unit.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.dat.Dat.iid_count" title="pysnptools.snpreader.dat.Dat.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.dat.Dat.iid_count" title="pysnptools.snpreader.dat.Dat.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer.unit</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.dat.Dat.names_of_other_files">
<tt class="descname">names_of_other_files</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.names_of_other_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.dat.Dat.names_of_other_files_static">
<em class="property">static </em><tt class="descname">names_of_other_files_static</tt><big>(</big><em>dat_filename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.names_of_other_files_static" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.dat.Dat.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.dat.Dat.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.dat.Dat.read" title="pysnptools.snpreader.dat.Dat.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.dat.Dat.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.dat.Dat.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.sid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.dat.Dat.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.dat.Dat.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.dat.Dat.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>snpdata</em>, <em>basefilename</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.dat.Dat.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.snpreader.hdf5">
<span id="snpreader-hdf5"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">snpreader.hdf5</span></tt><a class="headerlink" href="#module-pysnptools.snpreader.hdf5" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.snpreader.hdf5.Hdf5">
<em class="property">class </em><tt class="descclassname">pysnptools.snpreader.hdf5.</tt><tt class="descname">Hdf5</tt><big>(</big><em>filename</em>, <em>blocksize=5000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5" title="Permalink to this definition">¶</a></dt>
<dd><dl class="method">
<dt id="pysnptools.snpreader.hdf5.Hdf5.create_block">
<tt class="descname">create_block</tt><big>(</big><em>blocksize</em>, <em>order</em>, <em>dtype</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.create_block" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.hdf5.Hdf5.h5">
<tt class="descname">h5</tt><em class="property"> = None</em><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.h5" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.hdf5.Hdf5.iid">
<tt class="descname">iid</tt><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.iid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.hdf5.Hdf5.iid_count">
<tt class="descname">iid_count</tt><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.iid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of iids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.hdf5.Hdf5.iid_to_index">
<tt class="descname">iid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.iid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of iids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> &#8211; list of iids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">iid_to_index</span><span class="p">([[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;44&#39;</span><span class="p">],[</span><span class="s">&#39;POP1&#39;</span><span class="p">,</span><span class="s">&#39;12&#39;</span><span class="p">]])</span> <span class="c">#Find the indexes for two iids.</span>
<span class="go">[2 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.hdf5.Hdf5.is_sorted_without_repeats">
<em class="property">static </em><tt class="descname">is_sorted_without_repeats</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.is_sorted_without_repeats" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.hdf5.Hdf5.kernel">
<tt class="descname">kernel</tt><big>(</big><em>standardizer</em>, <em>allowlowrank=False</em>, <em>blocksize=10000</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.kernel" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a ndarray of size iid_count x iid_count. The returned array has the value of the standardized SNP values transposed and then multiplied with themselves.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>standardizer</strong> &#8211; &#8211; Specify standardization to be applied before the matrix multiply. Any <tt class="xref py py-class docutils literal"><span class="pre">standardizer</span></tt> may be used. Some choices include <a class="reference internal" href="#pysnptools.standardizer.identity.Identity" title="pysnptools.standardizer.identity.Identity"><tt class="xref py py-class docutils literal"><span class="pre">Identity</span></tt></a> 
(do nothing), <a class="reference internal" href="#pysnptools.standardizer.unit.Unit" title="pysnptools.standardizer.unit.Unit"><tt class="xref py py-class docutils literal"><span class="pre">Unit</span></tt></a> (make values for each SNP have mean zero and standard deviation 1.0), <tt class="xref py py-class docutils literal"><span class="pre">Beta</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySidCount</span></tt>, <tt class="xref py py-class docutils literal"><span class="pre">BySqrtSidCount</span></tt>.</li>
<li><strong>blocksize</strong> (<em>int or None</em>) &#8211; optional &#8211; Default of 10000. None means to load all. Suggested number of sids to read into memory at a time.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">ndarray of size <a class="reference internal" href="#pysnptools.snpreader.hdf5.Hdf5.iid_count" title="pysnptools.snpreader.hdf5.Hdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a> x <a class="reference internal" href="#pysnptools.snpreader.hdf5.Hdf5.iid_count" title="pysnptools.snpreader.hdf5.Hdf5.iid_count"><tt class="xref py py-attr docutils literal"><span class="pre">iid_count</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and allocates a new ndarray.</p>
<p>When applied to an read-from-disk SnpReader, such as <a class="reference internal" href="#pysnptools.snpreader.bed.Bed" title="pysnptools.snpreader.bed.Bed"><tt class="xref py py-class docutils literal"><span class="pre">Bed</span></tt></a>, the method can save memory by reading (and standardizing) the data in blocks.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.standardizer.unit</span> <span class="kn">import</span> <span class="n">Unit</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kernel</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">Unit</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">kernel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span> <span class="n">kernel</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span>
<span class="go">(300, 300) 901.421835903</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.hdf5.Hdf5.pos">
<tt class="descname">pos</tt><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.pos" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.hdf5.Hdf5.read">
<tt class="descname">read</tt><big>(</big><em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em>, <em>force_python_only=False</em>, <em>view_ok=False</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.read" title="Permalink to this definition">¶</a></dt>
<dd><p>Reads the SNP values and returns a <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> (with <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> property containing a new ndarray of the SNP values).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>order</strong> (<em>string or None</em>) &#8211; {&#8216;F&#8217; (default), &#8216;C&#8217;, &#8216;A&#8217;}, optional &#8211; Specify the order of the ndarray. If order is &#8216;F&#8217; (default),
then the array will be in F-contiguous order (iid-index varies the fastest).
If order is &#8216;C&#8217;, then the returned array will be in C-contiguous order (sid-index varies the fastest).
If order is &#8216;A&#8217;, then the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>
ndarray may be in any order (either C-, Fortran-contiguous, or even discontiguous).</li>
<li><strong>dtype</strong> (<em>data-type</em>) &#8211; {scipy.float64 (default), scipy.float32}, optional &#8211; The data-type for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a> ndarray.</li>
<li><strong>force_python_only</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), may use outside library code. If True, requests that the read
be done without outside library code.</li>
<li><strong>view_ok</strong> (<em>bool</em>) &#8211; optional &#8211; If False (default), allocates new memory for the <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.val" title="pysnptools.snpreader.snpdata.SnpData.val"><tt class="xref py py-attr docutils literal"><span class="pre">SnpData.val</span></tt></a>&#8216;s ndarray. If True,
if practical and reading from a <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>, will return a new 
<tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt> with a ndarray shares memory with the original <tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt>.
Typically, you&#8217;ll also wish to use &#8220;order=&#8217;A&#8217;&#8221; to increase the chance that sharing will be possible.
Use these parameters with care because any change to either ndarray (for example, via <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData.standardize" title="pysnptools.snpreader.snpdata.SnpData.standardize"><tt class="xref py py-meth docutils literal"><span class="pre">SnpData.standardize()</span></tt></a>) will effect
the others. Also keep in mind that <a class="reference internal" href="#pysnptools.snpreader.hdf5.Hdf5.read" title="pysnptools.snpreader.hdf5.Hdf5.read"><tt class="xref py py-meth docutils literal"><span class="pre">read()</span></tt></a> relies on ndarray&#8217;s mechanisms to decide whether to actually
share memory and so it may ignore your suggestion and allocate a new ndarray anyway.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a></p>
</td>
</tr>
</tbody>
</table>
<p>Calling the method again causes the SNP values to be re-read and creates a new in-memory <a class="reference internal" href="#pysnptools.snpreader.snpdata.SnpData" title="pysnptools.snpreader.snpdata.SnpData"><tt class="xref py py-class docutils literal"><span class="pre">SnpData</span></tt></a> with a new ndarray of SNP values.</p>
<p>If you request the values for only a subset of the sids or iids, (to the degree practical) only that subset will be read from disk.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpdata1</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># Read all the SNP data returning a SnpData instance</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="nb">type</span><span class="p">(</span><span class="n">snpdata1</span><span class="o">.</span><span class="n">val</span><span class="p">)</span> <span class="c"># The SnpData instance contains a ndarray of the data.</span>
<span class="go">&lt;type &#39;numpy.ndarray&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subset_snpdata</span> <span class="o">=</span> <span class="n">snp_on_disk</span><span class="p">[:,::</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="c"># From the disk, read SNP values for every other sid</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">subset_snpdata</span><span class="o">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span> <span class="c"># Print the first SNP value in the subset</span>
<span class="go">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">subsub_snpdata</span> <span class="o">=</span> <span class="n">subset_snpdata</span><span class="p">[:</span><span class="mi">10</span><span class="p">,:]</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="n">view_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c"># Create an in-memory subset of the subset with SNP values for the first ten iids. Share memory if practical.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># print np.may_share_memory(subset_snpdata.val, subsub_snpdata.val) # Do the two ndarray&#39;s share memory? They could. Currently they won&#39;t.       </span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.hdf5.Hdf5.read_direct">
<tt class="descname">read_direct</tt><big>(</big><em>snps</em>, <em>selection=(slice(None</em>, <em>None</em>, <em>None)</em>, <em>slice(None</em>, <em>None</em>, <em>None))</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.read_direct" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.hdf5.Hdf5.run_once">
<tt class="descname">run_once</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.run_once" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.hdf5.Hdf5.sid">
<tt class="descname">sid</tt><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.sid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="pysnptools.snpreader.hdf5.Hdf5.sid_count">
<tt class="descname">sid_count</tt><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.sid_count" title="Permalink to this definition">¶</a></dt>
<dd><p>number of sids</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">integer</td>
</tr>
</tbody>
</table>
<p>This property (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.snpreader.hdf5.Hdf5.sid_to_index">
<tt class="descname">sid_to_index</tt><big>(</big><em>list</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.sid_to_index" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of sids and returns a list of index numbers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>list</strong> (<em>list of strings</em>) &#8211; list of sids</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">ndarray of int</td>
</tr>
</tbody>
</table>
<p>This method (to the degree practical) reads only iid and sid data from the disk, not SNP value data. Moreover, the iid and sid data is read from file only once.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snp_on_disk</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">snp_on_disk</span><span class="o">.</span><span class="n">sid_to_index</span><span class="p">([</span><span class="s">&#39;1_10&#39;</span><span class="p">,</span><span class="s">&#39;1_13&#39;</span><span class="p">])</span> <span class="c">#Find the indexes for two sids.</span>
<span class="go">[2 9]</span>
</pre></div>
</div>
</dd></dl>

<dl class="staticmethod">
<dt id="pysnptools.snpreader.hdf5.Hdf5.write">
<em class="property">static </em><tt class="descname">write</tt><big>(</big><em>snpdata</em>, <em>hdf5file</em>, <em>dtype='f8'</em>, <em>snp_major=True</em><big>)</big><a class="headerlink" href="#pysnptools.snpreader.hdf5.Hdf5.write" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pysnptools.util">
<span id="util-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">util</span></tt> Module<a class="headerlink" href="#module-pysnptools.util" title="Permalink to this headline">¶</a></h2>
<div class="section" id="module-pysnptools.util.util">
<span id="util-util"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">util.util</span></tt><a class="headerlink" href="#module-pysnptools.util.util" title="Permalink to this headline">¶</a></h3>
<dl class="function">
<dt id="pysnptools.util.util.all_same">
<tt class="descclassname">pysnptools.util.util.</tt><tt class="descname">all_same</tt><big>(</big><em>iids_list</em><big>)</big><a class="headerlink" href="#pysnptools.util.util.all_same" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pysnptools.util.util.intersect_apply">
<tt class="descclassname">pysnptools.util.util.</tt><tt class="descname">intersect_apply</tt><big>(</big><em>data_list</em>, <em>sort_by_dataset=True</em><big>)</big><a class="headerlink" href="#pysnptools.util.util.intersect_apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Intersects and sorts the iids from a list of datasets, returning new version of the datasets with all the same iids in the same order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_list</strong> (<em>list</em>) &#8211; list of datasets</li>
<li><strong>sort_by_dataset</strong> (<em>bool</em>) &#8211; optional, If True (default), the iids are ordered according to the first non-None dataset.
If False, the order is arbitrary, but consistent.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list of datasets</p>
</td>
</tr>
</tbody>
</table>
<p>Here are the dataset formats understood and what is returned for each.</p>
<table border="1" class="docutils">
<colgroup>
<col width="42%" />
<col width="58%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Dataset Format</th>
<th class="head">What is Returned</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>None</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>A <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a></td>
<td>A new subsetting <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> with adjusted iid</td>
</tr>
<tr class="row-even"><td>A dictionary with [&#8216;iid&#8217;] and [&#8216;vals&#8217;] keys</td>
<td>The same dictionary but with the iid and vals values adjusted</td>
</tr>
<tr class="row-odd"><td>Tuple of the form (val ndarray, iid list)</td>
<td>A new tuple with the val ndarray and iid list adjusted</td>
</tr>
</tbody>
</table>
<p>If the iids in all the datasets are already the same and in the same order, then the datasets are returned without change.</p>
<p>Notice that only dictionaries are processed in-place. Inputting a <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> returns a new <a class="reference internal" href="#pysnptools.snpreader.snpreader.SnpReader" title="pysnptools.snpreader.snpreader.SnpReader"><tt class="xref py py-class docutils literal"><span class="pre">SnpReader</span></tt></a> (unless its iids
are already ok). Inputting a tuple returns a new tuple (unless its iids are already ok).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.snpreader.bed</span> <span class="kn">import</span> <span class="n">Bed</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pysnptools.util.pheno</span> <span class="kn">import</span> <span class="n">loadOnePhen</span><span class="p">,</span><span class="n">loadPhen</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c">#Create five datasets in different formats</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ignore_in</span> <span class="o">=</span> <span class="bp">None</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">snpreader_in</span> <span class="o">=</span> <span class="n">Bed</span><span class="p">(</span><span class="s">&#39;../../tests/datasets/all_chr.maf0.001.N300&#39;</span><span class="p">)</span> <span class="c"># Specify SNP data on disk</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pheno_dict</span> <span class="o">=</span> <span class="n">loadOnePhen</span><span class="p">(</span><span class="s">&#39;../../tests/datasets/phenSynthFrom22.23.N300.randcidorder.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov</span> <span class="o">=</span> <span class="n">loadPhen</span><span class="p">(</span><span class="s">&#39;../../tests/datasets/all_chr.maf0.001.covariates.N300.txt&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cov_as_tuple_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">cov</span><span class="p">[</span><span class="s">&#39;vals&#39;</span><span class="p">],</span><span class="n">cov</span><span class="p">[</span><span class="s">&#39;iid&#39;</span><span class="p">])</span> <span class="c">#We could do cov directly, but as an example we make it a tuple.</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Create five new datasets with consistent iids</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ignore_out</span><span class="p">,</span> <span class="n">snpreader_out</span><span class="p">,</span> <span class="n">pheno_dict</span><span class="p">,</span> <span class="n">cov_as_tuple_out</span> <span class="o">=</span> <span class="n">intersect_apply</span><span class="p">([</span><span class="n">ignore_in</span><span class="p">,</span> <span class="n">snpreader_in</span><span class="p">,</span> <span class="n">pheno_dict</span><span class="p">,</span> <span class="n">cov_as_tuple_in</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c"># Print the first five iids from each dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">ignore_out</span><span class="p">,</span> <span class="n">snpreader_out</span><span class="o">.</span><span class="n">iid</span><span class="p">[:</span><span class="mi">5</span><span class="p">],</span> <span class="n">pheno_dict</span><span class="p">[</span><span class="s">&#39;iid&#39;</span><span class="p">][:</span><span class="mi">5</span><span class="p">],</span> <span class="n">cov_as_tuple_out</span><span class="p">[</span><span class="mi">1</span><span class="p">][:</span><span class="mi">5</span><span class="p">]</span>
<span class="go">None [[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;58&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;65&#39;]] [[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;58&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;65&#39;]] [[&#39;POP1&#39; &#39;0&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;12&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;44&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;58&#39;]</span>
<span class="go"> [&#39;POP1&#39; &#39;65&#39;]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="pysnptools.util.util.intersect_ids">
<tt class="descclassname">pysnptools.util.util.</tt><tt class="descname">intersect_ids</tt><big>(</big><em>idslist</em><big>)</big><a class="headerlink" href="#pysnptools.util.util.intersect_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes a list of 2d string arrays of family and individual ids.
These are intersected.
Returns: indarr, an array of size N x L, where N is the number of</p>
<blockquote>
<div>individuals in the intersection, and L is the number of lists in idslist, and which
contains the index to use (in order) such that all people will be identical and in order
across all data sets.</div></blockquote>
<p>If one of the lists=None, it is ignored (but still has values reported in indarr, all equal to -1),</p>
</dd></dl>

<dl class="function">
<dt id="pysnptools.util.util.sub_matrix">
<tt class="descclassname">pysnptools.util.util.</tt><tt class="descname">sub_matrix</tt><big>(</big><em>val</em>, <em>iid_index</em>, <em>sid_index</em>, <em>order='F'</em>, <em>dtype=&lt;type 'numpy.float64'&gt;</em><big>)</big><a class="headerlink" href="#pysnptools.util.util.sub_matrix" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="util-intrangeset">
<h3><tt class="xref py py-mod docutils literal"><span class="pre">util.intrangeset</span></tt><a class="headerlink" href="#util-intrangeset" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.util.intrangeset.IntRangeSet">
<em class="property">class </em><tt class="descclassname">pysnptools.util.intrangeset.</tt><tt class="descname">IntRangeSet</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet" title="Permalink to this definition">¶</a></dt>
<dd><p>IntRangeSet is a class for manipulating ranges of integers (including longs) as sets. For example,
here we take the union of two IntRangeSets:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&quot;100-499,500-1000&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&quot;-20,400-600&quot;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;-20,100-1000&#39;)</span>
</pre></div>
</div>
<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.add">
<tt class="descname">add</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Union zero or more ranges inputs into the current IntRangeSet.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">+=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.add(b)</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.update(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">|=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0-10&#39;)</span>
</pre></div>
</div>
<p>The &#8216;add&#8217; and &#8216;update&#8217; methods also support unioning multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;5&#39;</span><span class="p">,</span><span class="s">&#39;100-200&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0-10,100-200&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.clear">
<tt class="descname">clear</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove all ranges from this IntRangeSet.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-9,12&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.copy">
<tt class="descname">copy</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.copy" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a deep copy of a IntRangeSet.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.count">
<tt class="descname">count</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.count" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of times that the elements of ranges appears in the IntRangeSet. Because IntRangeSet is 
a set, the number will be either 0 or 1.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100-110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s">&#39;105-107,1000&#39;</span><span class="p">)</span>
<span class="go">1</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.difference">
<tt class="descname">difference</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the set difference of a IntRangeSet with zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">-</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.difference(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="go">IntRangeSet(&#39;0,2-4,6-10&#39;)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="o">-</span> <span class="s">&#39;3-100&#39;</span>
<span class="go">IntRangeSet(&#39;0-2&#39;)</span>
</pre></div>
</div>
<p>The &#8216;difference&#8217; method also supports subtracting multiple input ranges</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="s">&#39;3-100&#39;</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0,2&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.difference_update">
<tt class="descname">difference_update</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.difference_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.discard">
<tt class="descname">discard</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.discard" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.index">
<tt class="descname">index</tt><big>(</big><em>other</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.index" title="Permalink to this definition">¶</a></dt>
<dd><p><tt class="docutils literal"><span class="pre">a.index(x)</span></tt>, index of the integer element x in a, an IntRangeSet. Raises an IndexError is x not in a.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100-110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">110</span><span class="p">)</span>
<span class="go">10</span>
</pre></div>
</div>
<p>x also can be any ranges input, in which case, an IntRangeSet is returned containing the indexes of all integers in x.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100-110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s">&#39;110,100-102&#39;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0-2,10&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.intersection">
<tt class="descname">intersection</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.intersection" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the intersection of a IntRangeSet and zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&amp;</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.intersection(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="s">&#39;3-7&#39;</span>
<span class="go">IntRangeSet(&#39;3-4,6-7&#39;)</span>
</pre></div>
</div>
<p>The &#8216;intersection&#8217; method also support intersecting multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="s">&#39;3-7&#39;</span><span class="p">,</span><span class="s">&#39;4-6&#39;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;4,6&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.intersection_update">
<tt class="descname">intersection_update</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.intersection_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.isdisjoint">
<tt class="descname">isdisjoint</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.isdisjoint" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the two sets have no integer elements in common.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100-110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="s">&#39;900-2000&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;100-110,1000&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="s">&#39;1900-2000&#39;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.util.intrangeset.IntRangeSet.isempty">
<tt class="descname">isempty</tt><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.isempty" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet is empty.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">()</span><span class="o">.</span><span class="n">isempty</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">isempty</span>
<span class="go">False</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.issubset">
<tt class="descname">issubset</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.issubset" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when the IntRangeSet is a subset of the ranges.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&lt;=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.issubset(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="s">&#39;-1-100&#39;</span> <span class="c"># The right-hand can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>Note: By definition, any set is a subset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.issuperset">
<tt class="descname">issuperset</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.issuperset" title="Permalink to this definition">¶</a></dt>
<dd><p>True exactly when all the ranges input is a subset of the IntRangeSet.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">b</span> <span class="pre">in</span> <span class="pre">a</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">&gt;=</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.issuperset(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="mi">3</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;4-6&#39;</span><span class="p">)</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="s">&#39;6-8&#39;</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="c"># The left-hand of &#39;in&#39; can be any ranges input</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="s">&#39;6-8&#39;</span> <span class="c"># The right-hand of can be any ranges input</span>
<span class="go">True</span>
</pre></div>
</div>
<p>The &#8216;issuperset&#8217; method also supports unioning multiple ranges inputs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">issuperset</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">7</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Note: By definition, any set is a superset of itself.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.max">
<tt class="descname">max</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.max" title="Permalink to this definition">¶</a></dt>
<dd><p>The largest integer element in the IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-9,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
<span class="go">12</span>
</pre></div>
</div>
<p>Note: This is more efficient than max(IntRangeSet(&#8216;0-9,12&#8217;)) because is computed
in constant time rather than in time linear to the number of integer elements.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.min">
<tt class="descname">min</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.min" title="Permalink to this definition">¶</a></dt>
<dd><p>The smallest integer element in the IntRangeSet</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-9,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
<span class="go">0</span>
</pre></div>
</div>
<p>Note: This is more efficient than <tt class="docutils literal"><span class="pre">min(IntRangeSet('0-9,12'))</span></tt> because is computed
in constant time rather than in time linear to the number of integer elements.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.pop">
<tt class="descname">pop</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.pop" title="Permalink to this definition">¶</a></dt>
<dd><p>Remove and return the largest integer element from the IntRangeSet. Raises KeyError if the IntRangeSet is empty.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
<span class="go">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span>
<span class="go">IntRangeSet(&#39;0-4,6-9&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.ranges">
<tt class="descname">ranges</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.ranges" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterate, in order, the ranges of a IntRangeSet as (start,last) tuples.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">start</span><span class="p">,</span><span class="n">last</span> <span class="ow">in</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-10,100-200&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ranges</span><span class="p">():</span>
<span class="gp">... </span>      <span class="k">print</span> <span class="s">&quot;start is {0}, last is {1}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">last</span><span class="p">)</span>
<span class="go">start is 0, last is 10</span>
<span class="go">start is 100, last is 200</span>
</pre></div>
</div>
</dd></dl>

<dl class="attribute">
<dt id="pysnptools.util.intrangeset.IntRangeSet.ranges_len">
<tt class="descname">ranges_len</tt><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.ranges_len" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of contiguous ranges in the IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-9,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">ranges_len</span>
<span class="go">2</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.remove">
<tt class="descname">remove</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.remove" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.sum">
<tt class="descname">sum</tt><big>(</big><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.sum" title="Permalink to this definition">¶</a></dt>
<dd><p>The sum of the integer elements in the IntRangeSet</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-9,12&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
<span class="go">57</span>
</pre></div>
</div>
<p>Note: This is more efficient than <tt class="docutils literal"><span class="pre">sum(IntRangeSet('0-9,12'))</span></tt> because is computed
in time linear in the number of ranges, rather than integer elements.</p>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.symmetric_difference">
<tt class="descname">symmetric_difference</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.symmetric_difference" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a new IntRangeSet set with elements in either the input IntRangeSet or the input range but not both.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">^</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.symmetric_difference(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="o">^</span> <span class="s">&#39;3-8&#39;</span>
<span class="go">IntRangeSet(&#39;0-2,5,9-10&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.symmetric_difference_update">
<tt class="descname">symmetric_difference_update</tt><big>(</big><em>ranges</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.symmetric_difference_update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.union">
<tt class="descname">union</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.union" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the union of a IntRangeSet with zero or more ranges inputs. The original IntRangeSet is not changed.</p>
<p>These are the same:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">|</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a</span> <span class="pre">+</span> <span class="pre">b</span></tt></li>
<li><tt class="docutils literal"><span class="pre">a.union(b)</span></tt></li>
</ul>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span> <span class="o">|</span> <span class="mi">5</span>
<span class="go">IntRangeSet(&#39;0-10&#39;)</span>
</pre></div>
</div>
<p>The &#8216;union&#8217; method also support unioning multiple ranges inputs,</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Example:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">IntRangeSet</span><span class="p">(</span><span class="s">&#39;0-4,6-10&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="s">&#39;100-200&#39;</span><span class="p">)</span>
<span class="go">IntRangeSet(&#39;0-10,100-200&#39;)</span>
</pre></div>
</div>
</dd></dl>

<dl class="method">
<dt id="pysnptools.util.intrangeset.IntRangeSet.update">
<tt class="descname">update</tt><big>(</big><em>*ranges_inputs</em><big>)</big><a class="headerlink" href="#pysnptools.util.intrangeset.IntRangeSet.update" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pysnptools.standardizer">
<span id="standardizer-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">standardizer</span></tt> Module<a class="headerlink" href="#module-pysnptools.standardizer" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="pysnptools.standardizer.factory">
<tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">factory</tt><big>(</big><em>s</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.factory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="pysnptools.standardizer.standardize_beta_python">
<tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">standardize_beta_python</tt><big>(</big><em>snps</em>, <em>betaA</em>, <em>betaB</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.standardize_beta_python" title="Permalink to this definition">¶</a></dt>
<dd><p>standardize snps with Beta prior</p>
</dd></dl>

<dl class="function">
<dt id="pysnptools.standardizer.standardize_unit_python">
<tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">standardize_unit_python</tt><big>(</big><em>snps</em>, <em>returnStats=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.standardize_unit_python" title="Permalink to this definition">¶</a></dt>
<dd><p>standardize snps to zero-mean and unit variance</p>
</dd></dl>

<dl class="function">
<dt id="pysnptools.standardizer.standardize_with_lambda">
<tt class="descclassname">pysnptools.standardizer.</tt><tt class="descname">standardize_with_lambda</tt><big>(</big><em>snps</em>, <em>lambdax</em>, <em>blocksize=None</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.standardize_with_lambda" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<div class="section" id="module-pysnptools.standardizer.unit">
<span id="standardizer-unit"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">standardizer.unit</span></tt><a class="headerlink" href="#module-pysnptools.standardizer.unit" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.unit.Unit">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.unit.</tt><tt class="descname">Unit</tt><a class="headerlink" href="#pysnptools.standardizer.unit.Unit" title="Permalink to this definition">¶</a></dt>
<dd><p>The specification for unit standardization</p>
<dl class="method">
<dt id="pysnptools.standardizer.unit.Unit.lambdaFactory">
<tt class="descname">lambdaFactory</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.unit.Unit.lambdaFactory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.standardizer.unit.Unit.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.unit.Unit.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.standardizer.identity">
<span id="standardizer-identity"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">standardizer.identity</span></tt><a class="headerlink" href="#module-pysnptools.standardizer.identity" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.identity.Identity">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.identity.</tt><tt class="descname">Identity</tt><a class="headerlink" href="#pysnptools.standardizer.identity.Identity" title="Permalink to this definition">¶</a></dt>
<dd><p>The specificiation for unit standardization</p>
<dl class="method">
<dt id="pysnptools.standardizer.identity.Identity.lambdaFactory">
<tt class="descname">lambdaFactory</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.identity.Identity.lambdaFactory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.standardizer.identity.Identity.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.identity.Identity.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.standardizer.beta">
<span id="standardizer-beta"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">standardizer.beta</span></tt><a class="headerlink" href="#module-pysnptools.standardizer.beta" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.beta.Beta">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.beta.</tt><tt class="descname">Beta</tt><big>(</big><em>a=1</em>, <em>b=25</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.beta.Beta" title="Permalink to this definition">¶</a></dt>
<dd><p>The specification for beta standardization</p>
<dl class="method">
<dt id="pysnptools.standardizer.beta.Beta.lambdaFactory">
<tt class="descname">lambdaFactory</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.beta.Beta.lambdaFactory" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="pysnptools.standardizer.beta.Beta.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.beta.Beta.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.standardizer.bysidcount">
<span id="standardizer-bysidcount"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">standardizer.bysidcount</span></tt><a class="headerlink" href="#module-pysnptools.standardizer.bysidcount" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.bysidcount.BySidCount">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.bysidcount.</tt><tt class="descname">BySidCount</tt><big>(</big><em>sid_count=None</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.bysidcount.BySidCount" title="Permalink to this definition">¶</a></dt>
<dd><p>The specificiation for BySidCount standardization</p>
<dl class="method">
<dt id="pysnptools.standardizer.bysidcount.BySidCount.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.bysidcount.BySidCount.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-pysnptools.standardizer.bysqrtsidcount">
<span id="standardizer-bysqrtsidcount"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">standardizer.bysqrtsidcount</span></tt><a class="headerlink" href="#module-pysnptools.standardizer.bysqrtsidcount" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.standardizer.bysqrtsidcount.BySqrtSidCount">
<em class="property">class </em><tt class="descclassname">pysnptools.standardizer.bysqrtsidcount.</tt><tt class="descname">BySqrtSidCount</tt><big>(</big><em>sid_count=None</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.bysqrtsidcount.BySqrtSidCount" title="Permalink to this definition">¶</a></dt>
<dd><p>The specificiation for BySqrtSidCount standardization</p>
<dl class="method">
<dt id="pysnptools.standardizer.bysqrtsidcount.BySqrtSidCount.standardize">
<tt class="descname">standardize</tt><big>(</big><em>snps</em>, <em>blocksize=None</em>, <em>force_python_only=False</em><big>)</big><a class="headerlink" href="#pysnptools.standardizer.bysqrtsidcount.BySqrtSidCount.standardize" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
</div>
<div class="section" id="module-pysnptools.altset_list">
<span id="altset-list-module"></span><h2><tt class="xref py py-mod docutils literal"><span class="pre">altset_list</span></tt> Module<a class="headerlink" href="#module-pysnptools.altset_list" title="Permalink to this headline">¶</a></h2>
<p>a altset_list is a list of snpsets</p>
<p>A altset_list is defined with two classes that implement these two interfaces: ISnpSetList and ISnpSetListPlusBed.
Note: Python doesn&#8217;t know enforce interfaces.</p>
<dl class="docutils">
<dt>interface ISnpSetList</dt>
<dd><dl class="first last docutils">
<dt>def addbed(self, bed):</dt>
<dd>return # ISnpSetListPlusBed</dd>
</dl>
</dd>
<dt>interface ISnpSetListPlusBed:</dt>
<dd><dl class="first last docutils">
<dt>def __len__(self):</dt>
<dd>return # number of snpsets in this list</dd>
<dt>def __iter__(self):</dt>
<dd>return # a sequence of ISnpSetPlusBed&#8217;s</dd>
</dl>
</dd>
</dl>
<div class="section" id="module-pysnptools.altset_list.consecutive">
<span id="altset-list-consecutive"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">altset_list.consecutive</span></tt><a class="headerlink" href="#module-pysnptools.altset_list.consecutive" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.altset_list.consecutive.Consecutive">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.consecutive.</tt><tt class="descname">Consecutive</tt><big>(</big><em>bimFileName</em>, <em>cMWindow</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.consecutive.Consecutive" title="Permalink to this definition">¶</a></dt>
<dd><p>The sets should be every consecutive set of SNPs within a 2cM window of each user 
(distance in cM is in the 3rd column of the bim file).  As for the name of the set,
please make it &lt;position-of-first-snp&gt;&#64;&lt;position-of-middle-snp&gt;&#64;&lt;position-of-last-snp&gt;.
For &#8216;middle&#8217; please break a tie to the first SNP.</p>
<dl class="method">
<dt id="pysnptools.altset_list.consecutive.Consecutive.addbed">
<tt class="descname">addbed</tt><big>(</big><em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.consecutive.Consecutive.addbed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysnptools.altset_list.consecutive.ConsecutivePlusBed">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.consecutive.</tt><tt class="descname">ConsecutivePlusBed</tt><big>(</big><em>spec</em>, <em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.consecutive.ConsecutivePlusBed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="module-pysnptools.altset_list.snpandsetnamecollection">
<span id="altset-list-snpandsetnamecollection"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">altset_list.snpandsetnamecollection</span></tt><a class="headerlink" href="#module-pysnptools.altset_list.snpandsetnamecollection" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.altset_list.snpandsetnamecollection.SnpAndSetNameCollection">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.snpandsetnamecollection.</tt><tt class="descname">SnpAndSetNameCollection</tt><big>(</big><em>filename</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.snpandsetnamecollection.SnpAndSetNameCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>Specifies a list of snp sets via a file that has columns &#8216;snp&#8217; and &#8216;group&#8217;.
See the Bed class&#8217;s &#8216;read&#8217; method of examples of its use.
See __init__.py for specification of interface it implements.</p>
<dl class="method">
<dt id="pysnptools.altset_list.snpandsetnamecollection.SnpAndSetNameCollection.addbed">
<tt class="descname">addbed</tt><big>(</big><em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.snpandsetnamecollection.SnpAndSetNameCollection.addbed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysnptools.altset_list.snpandsetnamecollection.SnpAndSetNameCollectionPlusBed">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.snpandsetnamecollection.</tt><tt class="descname">SnpAndSetNameCollectionPlusBed</tt><big>(</big><em>spec</em>, <em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.snpandsetnamecollection.SnpAndSetNameCollectionPlusBed" title="Permalink to this definition">¶</a></dt>
<dd><p>The SnpAndSetNameCollection with the addition of BED information.</p>
</dd></dl>

</div>
<div class="section" id="module-pysnptools.altset_list.subset">
<span id="altset-list-subset"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">altset_list.subset</span></tt><a class="headerlink" href="#module-pysnptools.altset_list.subset" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.altset_list.subset.Subset">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.subset.</tt><tt class="descname">Subset</tt><big>(</big><em>altset_list</em>, <em>subset_list</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.subset.Subset" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of the originally specified sets to test.
See the Bed class&#8217;s &#8216;read&#8217; method of examples of its use.
See __init__.py for specification of interface it implements.</p>
<dl class="method">
<dt id="pysnptools.altset_list.subset.Subset.addbed">
<tt class="descname">addbed</tt><big>(</big><em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.subset.Subset.addbed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysnptools.altset_list.subset.SubsetPlusBed">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.subset.</tt><tt class="descname">SubsetPlusBed</tt><big>(</big><em>spec</em>, <em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.subset.SubsetPlusBed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of the originally specified sets to test.</p>
</dd></dl>

</div>
<div class="section" id="module-pysnptools.altset_list.minmaxsetsize">
<span id="altset-list-minmaxsetsize"></span><h3><tt class="xref py py-mod docutils literal"><span class="pre">altset_list.minmaxsetsize</span></tt><a class="headerlink" href="#module-pysnptools.altset_list.minmaxsetsize" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pysnptools.altset_list.minmaxsetsize.MinMaxSetSize">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.minmaxsetsize.</tt><tt class="descname">MinMaxSetSize</tt><big>(</big><em>altset_list</em>, <em>minsetsize</em>, <em>maxsetsize</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.minmaxsetsize.MinMaxSetSize" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a subset of the originally specified sets where each group as at least minsetsize and no more than maxsetsize (inclusive).
minsetsize and maxsetsize can be None
See the Bed class&#8217;s &#8216;read&#8217; method of examples of its use.
See __init__.py for specification of interface it implements.</p>
<dl class="method">
<dt id="pysnptools.altset_list.minmaxsetsize.MinMaxSetSize.addbed">
<tt class="descname">addbed</tt><big>(</big><em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.minmaxsetsize.MinMaxSetSize.addbed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="pysnptools.altset_list.minmaxsetsize.MinMaxSetSizePlusBed">
<em class="property">class </em><tt class="descclassname">pysnptools.altset_list.minmaxsetsize.</tt><tt class="descname">MinMaxSetSizePlusBed</tt><big>(</big><em>spec</em>, <em>bed</em><big>)</big><a class="headerlink" href="#pysnptools.altset_list.minmaxsetsize.MinMaxSetSizePlusBed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</div>
<div class="section" id="indices-and-tables">
<h3>Indices and Tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li><a class="reference internal" href="genindex.html"><em>Index</em></a></li>
<li><a class="reference internal" href="py-modindex.html"><em>Module Index</em></a></li>
<li><a class="reference internal" href="search.html"><em>Search Page</em></a></li>
</ul>
</div></blockquote>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><tt class="docutils literal"><span class="pre">pysnptools</span></tt> Documentation</a><ul>
<li><a class="reference internal" href="#module-pysnptools.snpreader"><tt class="docutils literal"><span class="pre">snpreader</span></tt> Module</a><ul>
<li><a class="reference internal" href="#module-pysnptools.snpreader.snpreader"><tt class="docutils literal"><span class="pre">snpreader.snpreader</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.snpreader.bed"><tt class="docutils literal"><span class="pre">snpreader.bed</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.snpreader.snpdata"><tt class="docutils literal"><span class="pre">snpreader.snpdata</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.snpreader.ped"><tt class="docutils literal"><span class="pre">snpreader.ped</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.snpreader.dat"><tt class="docutils literal"><span class="pre">snpreader.dat</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.snpreader.hdf5"><tt class="docutils literal"><span class="pre">snpreader.hdf5</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pysnptools.util"><tt class="docutils literal"><span class="pre">util</span></tt> Module</a><ul>
<li><a class="reference internal" href="#module-pysnptools.util.util"><tt class="docutils literal"><span class="pre">util.util</span></tt></a></li>
<li><a class="reference internal" href="#util-intrangeset"><tt class="docutils literal"><span class="pre">util.intrangeset</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pysnptools.standardizer"><tt class="docutils literal"><span class="pre">standardizer</span></tt> Module</a><ul>
<li><a class="reference internal" href="#module-pysnptools.standardizer.unit"><tt class="docutils literal"><span class="pre">standardizer.unit</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.standardizer.identity"><tt class="docutils literal"><span class="pre">standardizer.identity</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.standardizer.beta"><tt class="docutils literal"><span class="pre">standardizer.beta</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.standardizer.bysidcount"><tt class="docutils literal"><span class="pre">standardizer.bysidcount</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.standardizer.bysqrtsidcount"><tt class="docutils literal"><span class="pre">standardizer.bysqrtsidcount</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-pysnptools.altset_list"><tt class="docutils literal"><span class="pre">altset_list</span></tt> Module</a><ul>
<li><a class="reference internal" href="#module-pysnptools.altset_list.consecutive"><tt class="docutils literal"><span class="pre">altset_list.consecutive</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.altset_list.snpandsetnamecollection"><tt class="docutils literal"><span class="pre">altset_list.snpandsetnamecollection</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.altset_list.subset"><tt class="docutils literal"><span class="pre">altset_list.subset</span></tt></a></li>
<li><a class="reference internal" href="#module-pysnptools.altset_list.minmaxsetsize"><tt class="docutils literal"><span class="pre">altset_list.minmaxsetsize</span></tt></a></li>
<li><a class="reference internal" href="#indices-and-tables">Indices and Tables</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="#">pysnptools 0.0.1 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Carl Kadie.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>